{"meta":{"title":"I AM SLOW WALKER, BUT I NEVER WALK BACK","subtitle":null,"description":null,"author":"darker","url":"http://lmwtuedu.cn","root":"/"},"pages":[{"title":"","date":"2019-09-12T10:45:39.090Z","updated":"2019-09-12T10:45:39.090Z","comments":false,"path":"categories/index.html","permalink":"http://lmwtuedu.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-09-12T10:44:37.747Z","updated":"2019-09-12T10:44:37.747Z","comments":false,"path":"tags/index.html","permalink":"http://lmwtuedu.cn/tags/index.html","excerpt":"","text":""},{"title":"About Me","date":"2019-09-16T02:13:34.000Z","updated":"2019-09-16T06:23:34.203Z","comments":true,"path":"about/index.html","permalink":"http://lmwtuedu.cn/about/index.html","excerpt":"","text":"I’m a code farmer"},{"title":"","date":"2019-09-16T09:31:38.995Z","updated":"2019-09-16T09:31:38.951Z","comments":true,"path":"ppxdeppx/J_P.html","permalink":"http://lmwtuedu.cn/ppxdeppx/J_P.html","excerpt":"","text":"一封情书J&P 本页面采用HTML5编辑，目前您的浏览器无法显示，请换成谷歌(Chrome)或者火狐(Firefox)浏览器，或者其他游览器的最新版本。 J&P 耳语 嗨，ca gi ya，还记得我们相识的场景吗？ 还记得你约我看电影的那天吗？ 还记得我为你做的第一次饭吗？ 还记得我担心你胃疼，全身着急冒汗吗？ 还记得我们晚上去海上世界浪吗？ 还记得.... 你我的回忆,好多好多留在微信的聊天记录了 上天的眷顾，让我在茫茫人海遇见你～～ 往后余生，我的身边多了一个人惦记的人 你是我的软肋 you are my favorite medicine 你是我的想度过余生的人 生活都不是一帆风顺，何况爱情呢？ 这条路上会有喜悦和快乐、会有争吵、会有打闹、会有莫名其妙的发脾气 但是这所有的一切一切都是你我的故事，酸甜苦辣，有我在你身边 一直陪着你，有杰哥哥呢～ 还记得情书💌写的一段话吗？ 春日宴 绿酒一杯歌一遍，再拜呈三原 一愿郎君千岁，二愿妾身康健 三愿如同梁上燕，岁岁常相见 亲爱的 你笑起来炒鸡炒鸡美的呢～ 七夕情人节快乐，biu biu biu 最后撒🌹🌹🌹🌹🌹🌹🌹🌹🌹 -- darker-- 皮皮虾与 皮皮熊已经相识了 (function(){ var canvas = $('#canvas'); if (!canvas[0].getContext) { $(\"#error\").show(); return false; } var width = canvas.width(); var height = canvas.height(); canvas.attr(\"width\", width); canvas.attr(\"height\", height); var opts = { seed: { x: width / 2 - 20, color: \"rgb(190, 26, 37)\", scale: 2 }, branch: [ [535, 680, 570, 250, 500, 200, 30, 100, [ [540, 500, 455, 417, 340, 400, 13, 100, [ [450, 435, 434, 430, 394, 395, 2, 40] ]], [550, 445, 600, 356, 680, 345, 12, 100, [ [578, 400, 648, 409, 661, 426, 3, 80] ]], [539, 281, 537, 248, 534, 217, 3, 40], [546, 397, 413, 247, 328, 244, 9, 80, [ [427, 286, 383, 253, 371, 205, 2, 40], [498, 345, 435, 315, 395, 330, 4, 60] ]], [546, 357, 608, 252, 678, 221, 6, 100, [ [590, 293, 646, 277, 648, 271, 2, 80] ]] ]] ], bloom: { num: 700, width: 1080, height: 650, }, footer: { width: 1200, height: 5, speed: 10, } } var tree = new Tree(canvas[0], width, height, opts); var seed = tree.seed; var foot = tree.footer; var hold = 1; canvas.click(function(e) { var offset = canvas.offset(), x, y; x = e.pageX - offset.left; y = e.pageY - offset.top; if (seed.hover(x, y)) { hold = 0; canvas.unbind(\"click\"); canvas.unbind(\"mousemove\"); canvas.removeClass('hand'); } }).mousemove(function(e){ var offset = canvas.offset(), x, y; x = e.pageX - offset.left; y = e.pageY - offset.top; canvas.toggleClass('hand', seed.hover(x, y)); }); var seedAnimate = eval(Jscex.compile(\"async\", function () { seed.draw(); while (hold) { $await(Jscex.Async.sleep(10)); } while (seed.canScale()) { seed.scale(0.95); $await(Jscex.Async.sleep(10)); } while (seed.canMove()) { seed.move(0, 2); foot.draw(); $await(Jscex.Async.sleep(10)); } })); var growAnimate = eval(Jscex.compile(\"async\", function () { do { tree.grow(); $await(Jscex.Async.sleep(10)); } while (tree.canGrow()); })); var flowAnimate = eval(Jscex.compile(\"async\", function () { do { tree.flower(2); $await(Jscex.Async.sleep(10)); } while (tree.canFlower()); })); var moveAnimate = eval(Jscex.compile(\"async\", function () { tree.snapshot(\"p1\", 240, 0, 610, 680); while (tree.move(\"p1\", 500, 0)) { foot.draw(); $await(Jscex.Async.sleep(10)); } foot.draw(); tree.snapshot(\"p2\", 500, 0, 610, 680); // 会有闪烁不得意这样做, (＞﹏＜) canvas.parent().css(\"background\", \"url(\" + tree.toDataURL('image/png') + \")\"); canvas.css(\"background\", \"#ffe\"); $await(Jscex.Async.sleep(300)); canvas.css(\"background\", \"none\"); })); var jumpAnimate = eval(Jscex.compile(\"async\", function () { var ctx = tree.ctx; while (true) { tree.ctx.clearRect(0, 0, width, height); tree.jump(); foot.draw(); $await(Jscex.Async.sleep(25)); } })); var textAnimate = eval(Jscex.compile(\"async\", function () { var together = new Date(); together.setFullYear(2018, 04, 04); //时间年月日 together.setHours(0); //小时 together.setMinutes(0); //分钟 together.setSeconds(0); //秒前一位 together.setMilliseconds(2); //秒第二位 $(\"#code\").show().typewriter(); $(\"#clock-box\").fadeIn(500); while (true) { timeElapse(together); $await(Jscex.Async.sleep(1000)); } })); var runAsync = eval(Jscex.compile(\"async\", function () { $await(seedAnimate()); $await(growAnimate()); $await(flowAnimate()); $await(moveAnimate()); textAnimate().start(); $await(jumpAnimate()); })); runAsync().start(); })();"},{"title":"予你耳语","date":"2019-09-16T09:02:30.193Z","updated":"2019-08-15T06:30:56.000Z","comments":true,"path":"ppxdeppx/z_love_letter.html","permalink":"http://lmwtuedu.cn/ppxdeppx/z_love_letter.html","excerpt":"","text":"《予J&P的话语》 2018.05.24/ J to P：虽然我现在赚钱不多，日后也不知能不能养得起你，但是我愿意一边爱你，一边努力的挣钱！ 2018.05.25/ J to P: 不要怕，我有在呢！你要记住我对你说过的一些话，我会宠你像个孩子一样！ 2018.05.27/ J to P: 今天你突然胃疼 你弯腰捂腹部时，吓死我了；看着你额头的汗水和紧皱的眉头；我的心也跟着揪起来，看你难受我也难受；回去地铁路上我替你捂着腹部，你刷这抖音转移着疼痛，笑呵呵的，好像刚才事情没发生似的；我知道你是不想让我担心！为了不让我担心，你得多照顾自己的饮食；PS：哼，以后要好好“管”一下你的饮食！ 2018.05.28/ J to P： 昨天看你难受，我几度哽咽；我慢慢知道你已经渐渐成为我的软肋！ 2018.05.29/ J to P： 你说你梦到我了，我们一起回到学生时代，我知道其实是你想我了，我也想你呀～ 2018.05.30/ J to P： 今天看到一段很撩的话，想和你一起分享：“Hey， Can you smile?” \"Why?\" \"Cause I forget to put sugar in my coffee\" 2018.05.31/ J to P：以前的人生我无法改变它应该怎样怎样过，因为它已经是往事，我只想着以后的人生与你应该怎么过；还记得我曾经跟你说过的话吗？ 我是一个向前看的人，无论以前的人生是多么的稀烂和多么辉煌，那都是过去；既然过去了，何必揪着不放呢！现在我属于你，你属于我，不是吗？^_^ 2018.06.04/ J to P：今天是一个特别的日子，大手牵小手，一直幸福下去哟！ PS：敲打字符时，突然收到你对我说的一句话，心里好暖，好幸福～ 2018.06.05/ J to P：梦到一个和你有关的梦； 啦啦啦，晚一点，偷偷告诉你哟～ 2018.06.08/ J to P： SZ这座城市，这几天暴雨来袭，夜晚听着雨滴敲打着门窗的声音，很想念你，雨滴的声音犹如我对你的思念，慢慢随着音符飘向远方～ 2018.06.14/ J to P： \"爱就像蓝天白云，晴空万里，突然暴风雨...\", 有时夜晚的思念很是强烈，翻来覆去；心里默默想念着你睡去，偶尔会在夜晚醒来（PS：你在我身边时，睡的很踏实^_^ ） 2018.06.22/ J to P： 翻阅以前的聊天记录，突然被你我的对话内容暖到了；虽然有时有相思之苦，但是心里一直都是甜的; 有你在我身边，我很幸福，心里一直美滋滋呢！有时会傻笑，偷偷自己乐呵； 我知道，在和你一起的日子，你已经成为了生活的一部分； 有时给你发消息，没见你回消息；心里会七上八下的；见到你回了消息，心才会平静！我知道这是深爱一个人的表现，会牵挂她的一切； 心里会是不是时刻的想着她，想着想着就偷偷的乐呵，嘻嘻嘻～～ 你知道为啥我每次都送你回家，我很自私，我想在这世间有限的时间，陪你多一点；就像我对你的爱多你一丢丢！ “你在我身边的时候，我重来没有羡慕过身边任何人”，亲爱的，余生，说长也不长，说短也不短；余生还请多多包容和指教～ 2018.07.02/ J to P： 渡人者渡也～ 2018.07.03/ J to P： 0702 21:54 关掉视频，双眼还是掩不住眼泪狂掉～ 第二次为你落泪了；我不知道你这堵南墙，我还要为它撞几次～ 2018.07.03/ J to P：我知道有些事情，我们必须一起经历磨练，我们的爱情才会经得起风雨～ 爱情永远都没有那么容易，我们要一起好好经营，好吗？ 别再让我心痛了～（PS：有时真的好痛好痛，痛的我揪心的疼～） 2018.07.05/ J to P： SZ 天气多变，雨水偏多～ 记得带雨伞哟，附上一张美丽的晚霞吧～～ 2018.07.16 J to P： 心中有思念所以时刻想念～ 2018.07.18 J to P： 茶几呀～～ 我看到一句很有意思的话想和你分享 “人生重要的是目标感，就像升级打怪 ，在关卡和关卡的缝隙处，才有被自己容许颓废的自由空间” 是的，人生最觉得难走的路程，最终都会慢慢走过～～ 没有什么东西是过不掉的坎坷 2018.07.27 J to P： 昨天夜晚很想念你时，脑海闪过这样一句话 “此生只许三生愿，一生就想陪你到白头～”，啦啦啦～，不知道有木有这样的话语，木有就是JGG原创的啦～～嘻嘻～～ 2019.07.01 J to P： 好久没写了，停更也快一年了吧，亲爱的皮皮熊也已经变成皮皮虾的老婆啦（好开心~~）！ 人生奇妙呀，余生很长，皮皮虾也在慢慢成长，皮皮熊也在慢慢变得优秀；烦恼的事情也有，但是快乐总比烦恼多，身边有你，总是让我内心很舒坦；淘气的你也会让我很焦躁，哈哈哈（真是言不由衷呀，内心其实笑开了花）~~ 未来皮皮虾也会变得越来越好，皮皮熊也会变得越来越好，嘻嘻嘻~~~ 2019.07.05 J to P： 我要和你在美丽的冬天雪地里亲吻，还要和你在迷人的秋天枫叶下亲吻， 还要和你在蓝蓝的夏日海边亲吻，还要和你在百花齐放的春天里亲吻..... 还有一起在冬天的雪地里奔跑..... 嘻嘻~~ 2019.07.08 J to P： 难得做一次豆角烧腊肉焖面不错，超级超级好吃，亲爱的都吃撑了，嘻嘻~~; PS：人间烟火气最抚凡人心，所以我喜欢做饭给心爱的人吃~ 2019.08.15 J to P： 最近一直听， 三旬，三十而立，正在奔跑在未来道路上，昨天和亲爱的 讨论“好日子到头了”，是呀，你我都已经为人父母，谁不是谁的宝贝呢~ 在时间长河流中，你我逐渐慢慢成为一个合格的父母，懂得为人妻，为人父。懂得忍受生活 的艰辛，懂得生活的酸甜苦辣。尽管生活常常不如我们意愿，但是我们都要微笑面对呀，是不是呀，老婆大人~ 生活虽然很苦，但是有亲爱的这个糖，让我也觉得 很甜~~ 爱你哟，亲爱的老婆~"},{"title":"Article Links","date":"2019-09-18T03:06:44.373Z","updated":"2019-09-18T03:06:44.373Z","comments":false,"path":"share/index.html","permalink":"http://lmwtuedu.cn/share/index.html","excerpt":"","text":"@card{ Permanently update excellent article linksif you don’t want men to paste your article link, Please email to me, i will delete it. } @column-2{ @card{ dubbo source analysisdubbo source analysis articles dubbo源码解析（一）Hello,Dubbodubbo源码解析（二）Dubbo扩展机制SPIdubbo源码解析（三）注册中心——开篇dubbo源码解析（四）注册中心——dubbodubbo源码解析（五）注册中心——multicastdubbo源码解析（六）注册中心——redisdubbo源码解析（七）注册中心——zookeeperdubbo源码解析（八）远程通信——开篇dubbo源码解析（九）远程通信——Transport层dubbo源码解析（十）远程通信——Exchange层dubbo源码解析（十一）远程通信——Bufferdubbo源码解析（十二）远程通信——Telnetdubbo源码解析（十三）远程通信——Grizzlydubbo源码解析（十四）远程通信——Httpdubbo源码解析（十五）远程通信——Minadubbo源码解析（十六）远程通信——Netty3dubbo源码解析（十七）远程通信——Netty4dubbo源码解析（十八）远程通信——Zookeeperdubbo源码解析（十九）远程调用——开篇dubbo源码解析（二十）远程调用——Filterdubbo源码解析（二十一）远程调用——Listenerdubbo源码解析（二十二）远程调用——Protocoldubbo源码解析（二十三）远程调用——Proxydubbo源码解析（二十四）远程调用——dubbo协议dubbo源码解析（二十五）远程调用——hessian协议dubbo源码解析（二十六）远程调用——http协议dubbo源码解析（二十七）远程调用——injvm本地调用dubbo源码解析（二十八）远程调用——memcached协议dubbo源码解析（二十九）远程调用——redis协议dubbo源码解析（三十）远程调用——rest协议dubbo源码解析（三十一）远程调用——rmi协议dubbo源码解析（三十二）远程调用——thrift协议dubbo源码解析（三十三）远程调用——webservice协议dubbo源码解析（三十四）集群——开篇dubbo源码解析（三十五）集群——clusterdubbo源码解析（三十六）集群——configuratordubbo源码解析（三十七）集群——directorydubbo源码解析（三十八）集群——LoadBalancedubbo源码解析（三十九）集群——mergerdubbo源码解析（四十）集群——routerdubbo源码解析（四十一）集群——Mockdubbo源码解析（四十二）序列化——开篇dubbo源码解析（四十三）2.7新特性dubbo源码解析（四十四）服务暴露过程dubbo源码解析（四十五）服务引用过程dubbo源码解析（四十六）消费端发送请求过程dubbo源码解析（四十七）服务端处理请求过程dubbo源码解析（四十八）异步化改造 } @card{ 直达航班✈️✈️UI界面 沧海一滴后台UI管理UI的选择 Spring 沧海一滴Spring RestTemplate 专题 沧海一滴restful风格，restcontroller与controller Github 沧海一滴Github优秀java项目集合（中文版） - 涉及java所有的知识体系 – good 集合 List - ArrayList源码分析 List - LinkedList源码分析 List - CopyOnWriteArrayList源码分析 Map - HashMap源码分析 Map - WeakHashMap源码分析 Map - ConcurrentHashMap 源码分析（一） Map - ConcurrentHashMap 源码分析（二） Set - HashSet源码分析 Set - LinkedHashSet源码分析 Map - ConcurrentSkipListMap源码分析 Set - CopyOnWriteArraySet源码分析 Set - ConcurrentSkipListSet源码分析 Queue - PriorityQueue源码分析 Queue - ArrayBlockingQueue源码分析 Queue - LinkedBlockingQueue源码分析 Queue - DelayQueue源码分析 JVM专栏 JVM系列(一) Java类的加载机 JVM系列(二) JVM内存结构 JVM系列(三) Java GC算法 垃圾收集器 JVM系列(四) JVM调优-命令大全(jsp jstat jmap jhat jstack jinfo) JVM系列(五) tomcat性能调优和性能监控(vsualvm) JVM系列(六) JVM调优——从eclipse开始 JVM系列(七) JVM调优——工具篇 JVM系列(八) JVM知识点总览 JVM系列(九) Java GC分析 JVM系列(十) 如何优化 Java GC「翻译」 开源优秀框架 Google Guava Collections 高手之路 为什么掌握 UML 建模是成为编程高手的一条捷径？ DockerCentOS内核升级 } }"}],"posts":[{"title":"燕十八的MYSQL练习","slug":"2018-10-17-燕十八MYSQL练习","date":"2018-10-16T16:00:00.000Z","updated":"2019-09-17T08:34:06.081Z","comments":true,"path":"2018/10/17/2018-10-17-燕十八MYSQL练习/","link":"","permalink":"http://lmwtuedu.cn/2018/10/17/2018-10-17-燕十八MYSQL练习/","excerpt":"","text":"燕十八的MYSQL练习123456789101112131415161718192021222324252627282930313233343536373839404142434445create table goods ( goods_id mediumint(8) unsigned primary key auto_increment, goods_name varchar(120) not null default '', cat_id smallint(5) unsigned not null default '0', brand_id smallint(5) unsigned not null default '0', goods_sn char(15) not null default '', goods_number smallint(5) unsigned not null default '0', shop_price decimal(10,2) unsigned not null default '0.00', market_price decimal(10,2) unsigned not null default '0.00', click_count int(10) unsigned not null default '0') engine=myisam default charset=utf8;insert into `goods` values (1,'kd876',4,8,'ecs000000',1,1388.00,1665.60,9),(4,'诺基亚n85原装充电器',8,1,'ecs000004',17,58.00,69.60,0),(3,'诺基亚原装5800耳机',8,1,'ecs000002',24,68.00,81.60,3),(5,'索爱原装m2卡读卡器',11,7,'ecs000005',8,20.00,24.00,3),(6,'胜创kingmax内存卡',11,0,'ecs000006',15,42.00,50.40,0),(7,'诺基亚n85原装立体声耳机hs-82',8,1,'ecs000007',20,100.00,120.00,0),(8,'飞利浦9@9v',3,4,'ecs000008',1,399.00,478.79,10),(9,'诺基亚e66',3,1,'ecs000009',4,2298.00,2757.60,20),(10,'索爱c702c',3,7,'ecs000010',7,1328.00,1593.60,11),(11,'索爱c702c',3,7,'ecs000011',1,1300.00,0.00,0),(12,'摩托罗拉a810',3,2,'ecs000012',8,983.00,1179.60,13),(13,'诺基亚5320 xpressmusic',3,1,'ecs000013',8,1311.00,1573.20,13),(14,'诺基亚5800xm',4,1,'ecs000014',1,2625.00,3150.00,6),(15,'摩托罗拉a810',3,2,'ecs000015',3,788.00,945.60,8),(16,'恒基伟业g101',2,11,'ecs000016',0,823.33,988.00,3),(17,'夏新n7',3,5,'ecs000017',1,2300.00,2760.00,2),(18,'夏新t5',4,5,'ecs000018',1,2878.00,3453.60,0),(19,'三星sgh-f258',3,6,'ecs000019',12,858.00,1029.60,7),(20,'三星bc01',3,6,'ecs000020',12,280.00,336.00,14),(21,'金立 a30',3,10,'ecs000021',40,2000.00,2400.00,4),(22,'多普达touch hd',3,3,'ecs000022',1,5999.00,7198.80,16),(23,'诺基亚n96',5,1,'ecs000023',8,3700.00,4440.00,17),(24,'p806',3,9,'ecs000024',100,2000.00,2400.00,35),(25,'小灵通/固话50元充值卡',13,0,'ecs000025',2,48.00,57.59,0),(26,'小灵通/固话20元充值卡',13,0,'ecs000026',2,19.00,22.80,0),(27,'联通100元充值卡',15,0,'ecs000027',2,95.00,100.00,0),(28,'联通50元充值卡',15,0,'ecs000028',0,45.00,50.00,0),(29,'移动100元充值卡',14,0,'ecs000029',0,90.00,0.00,0),(30,'移动20元充值卡',14,0,'ecs000030',9,18.00,21.00,1),(31,'摩托罗拉e8 ',3,2,'ecs000031',1,1337.00,1604.39,5),(32,'诺基亚n85',3,1,'ecs000032',4,3010.00,3612.00,9); where1.0 查询主键微32的商品 1select * from goods where goods_id = 32; 1.1 不属于第3栏目的所有商品 1select *from goods where cat_id !=3; 1.2 本店价格高于3000元的商品 1select *from goods where shop_price &gt; 3000; 1.3 本店价格低于或等于100元的商品 1select *from goods where shop_price &lt;=100; 1.4 取出第4栏目或第11栏目的商品(不许用or) 1select *from goods where cat_id in (4,11); 1.5 取出100&lt;=价格&lt;=500的商品(不许用and) 1select * from goods where shop_price between 100 and 500; 1.6 取出不属于第3栏目且不属于第11栏目的商品(and,或not in分别实现) 12select * from goods where cat_id !=3 and cat_id != 11;select * from goods where cat_id not in(3,11); 1.7 取出价格大于100且小于300,或者大于4000且小于5000的商品() 1select * from goods where (shop_price &gt; 100 and shop_price &lt; 300) or (shop_price &gt; 4000 and shop_price &lt; 5000); 1.8 取出第3个栏目下面价格&lt;1000或&gt;3000,并且点击量&gt;5的系列商品 123select * from goods where cat_id =3 and (shop_price &lt;1000 or shop_price &gt;3000) and click_count &gt; 5;select * from goods where cat_id =3 and ( shop_price not between 1000 and 3000) and click_count &gt; 5; 1.10 取出名字以”诺基亚”开头的商品 1select * from goods where goods_name like \"诺基亚%\"; 1.11 取出名字为”诺基亚Nxx”的手机 1select * from goods where goods_name like \"诺基亚N%\"; 1.12 取出名字不以”诺基亚”开头的商品 1select * from goods where goods_name not like \"诺基亚%\"; 1.13 取出第3个栏目下面价格在1000到3000之间,并且点击量&gt;5 “诺基亚”开头的系列商品 1select *from goods where cat_id =3 and (shop_price between 1000 and 3000 ) and click_count &gt;5 and goods_name like \"诺基亚%\"; 1.14 把good表中商品名为’诺基亚xxxx’的商品,改为’HTCxxxx’, 提示:大胆的把列看成变量,参与运算,甚至调用函数来处理.substring(),concat() 1select concat(\"HTC\",substring(goods_name,4)) from goods where goods_name like '诺基亚%'; group2.1 查出最贵的商品的价格 1234select max(shop_price) from goods;## #查询具体的最贵的商品信息select goods_id, goods_name,shop_price from goods,(select max(shop_price) as sp from goods) maxp where goods.shop_price = sp; 2.2 查出最大(最新)的商品编号 1select max(goods_id) from goods; 2.3 查出最便宜的商品的价格 1select min(shop_price) from goods; 2.4 查出最旧(最小)的商品编号 1select min(goods_id) from goods; 2.5 查询该店所有商品的库存总量 1select sum(goods_number) from goods; 2.6 查询所有商品的平均价 1234select avg(shop_price) from goods;## 每类商品均价select cat_id, avg(shop_price) from goods group by cat_id; 2.7 查询该店一共有多少种商品 1select count(*) from goods; having与group综合运用3.1 查询该店的商品比市场价所节省的价格: 1select goods_id, goods_name, (shop_price - market_price) from goods; 3.2 查询每个商品所积压的货款(提示:库存*单价) 1select goods_id, goods_name ,(shop_price*goods_number) from goods; 3.3 查询该店积压的总货款 1select sum(shop_price*goods_number) from goods; 3.4 查询该店每个栏目下面积压的货款. 1select cat_id, sum(shop_price*goods_number) from goods group by cat_id; 3.5 查询比市场价省钱200元以上的商品及该商品所省的钱(where和having分别实现) 12345# whereselect * , (market_price -shop_price) from goods where (market_price -shop_price) &gt; 200;# havingselect * , (market_price -shop_price) as shengqian from goods having shengqian &gt; 200; 3.6 查询积压货款超过2W元的栏目,以及该栏目积压的货款 1select cat_id, sum(shop_price*goods_number) as sum_cat_price from goods group by cat_id having sum_cat_price &gt; 20000; 练习12345678910111213CREATE TABLE `lesson_score` ( `name` varchar(20) DEFAULT NULL, `subject` varchar(20) DEFAULT NULL, `score` tinyint(4) DEFAULT NULL) CHARSET=utf8;insert into lesson_scorevalues('张三','数学',90),('张三','语文',50),('张三','地理',40),('李四','语文',55),('李四','政治',45),('王五','政治',30); 要求:查询出2门及2门以上不及格者的平均成绩 错误 12## 这种写法错误select name , count(score &lt; 60) as num, avg(score) from lesson_score group by name having num &gt;= 2; 注意： count,是数行数的，其实与里面是啥没有关系，所以 score &lt; 60 没有生效。 count(score &lt; 60) 只是统计行数。 所以重新添加数据，注意图片显示。 平均成绩 挂科情况 12345678910111213## 挂科情况select name, score &lt; 60 from lesson_score;## 注意 score&lt;60 的结果只有两种，0和1## 那么我们可以统计 name 的总共的挂科情况select name, sum((score&lt;60)) from lesson_score group by name;## 此时我们得到总体的挂科数量## 挂科 &gt;=2 的人我们是不是可以查询到select name, sum((score&lt;60))&gt;=2 from lesson_score group by name;## 那么我们可以这么写：select name, avg(score), sum((score&lt;60)) as num from lesson_score group by name having num &gt;=2; order by 与 limit 查询4.1 按价格由高到低排序 1select * from goods order by shop_price desc; 4.2 按发布时间由早到晚排序 1select * from goods order by add_time; 4.3 接栏目由低到高排序,栏目内部按价格由高到低排序 1select * from goods order by cat_id, shop_price desc; 4.4 取出价格最高的前三名商品 1select * from goods order by shop_price desc limit 0,3; 4.5 取出点击量前三名到前5名的商品 1select * from goods order by click_count desc limit 2,3; 4.6","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://lmwtuedu.cn/categories/MYSQL/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"http://lmwtuedu.cn/tags/MYSQL/"}],"author":"LJ"},{"title":"Redis（01）笔记","slug":"2018-09-20-Redis笔记_01","date":"2018-09-19T16:00:00.000Z","updated":"2019-09-17T08:20:05.256Z","comments":true,"path":"2018/09/20/2018-09-20-Redis笔记_01/","link":"","permalink":"http://lmwtuedu.cn/2018/09/20/2018-09-20-Redis笔记_01/","excerpt":"","text":"#Redis笔记01 工作中也常常用到redis，对Redis的使用也是停留在一些操作上面，工作上也遇到要用redis的场景，例如：单点登录、缓存数据库（热点数据）、高并发某些特定业务的优化等；一直忙于项目，没有时间整理，前段时间买了一本掘金 老钱的Redis，觉得不错，顺便整理一下redis的知识，如有错误地方，请指正。 基础数据结构 string: 字符串 list: 列表 set: 集合 hash: 哈希 zset: 有序集合 封装了基本的线程池以及工具类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.darker.redis;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * @auther lj * @date 2018/9/17 16:53 * @email lmwtuedu@163.com */public class RedisPool &#123; public static Logger log = LoggerFactory.getLogger(RedisPool.class); /** * 线程池的配置，继承于apache common pool2 */ private JedisPoolConfig jedisPoolConfig; /** * redis的IP地址 */ private String ip; /** * redis的端口号 */ private int port; /** * redis的密码 */ private String password; /** * 可用连接实例的最大数目，默认值为8； */ private int maxTotal; private int maxIdle; /** * 等待可用连接的最大时间，单位毫秒， * 默认值为-1，表示永不超时。如果超过等待时间， * 则直接抛出JedisConnectionException； */ private long maxWaitMillis; /** * redis的线程池 */ private JedisPool jedisPool; /** * 初始化Redis连接池 */ public void initialPool() &#123; try &#123; jedisPool = new JedisPool(jedisPoolConfig, ip, port, 4000, password); &#125; catch (Exception e) &#123; log.error(\"First create JedisPool error : \" + e); &#125; &#125; /** * 获取Instance * @return */ public Jedis getInstance()&#123; return jedisPool.getResource(); &#125; /** * 回收redis * 注意：returnResource * returnBrokenResource * 两种方法封装close * @param jedis */ public void close(Jedis jedis)&#123; jedis.close(); &#125;&#125; 封装了一个Manger的类工具，专门管理redis的操作。 1234567891011121314151617181920212223242526package com.darker.redis;import redis.clients.jedis.Jedis;/** * @auther lj * @date 2018/9/18 10:50 * @email lmwtuedu@163.com */public class RedisManager &#123; private RedisPool redisPool; public RedisManager(RedisPool redisPool) &#123; this.redisPool = redisPool; &#125; public Jedis getRedis()&#123; return redisPool.getInstance(); &#125; public void close(Jedis jedis)&#123; redisPool.close(jedis); &#125; ..... &#125; 以下基于基本的类型，给予操作，以及一些使用场景。 String 字符串的结构使用非常广泛，一个常见的用途就是缓存用户信息； 怎么缓存用户信息呢？ 例如用户信息是一个对象或者是一个JSON，推荐采用json，键值对方式容易扩张，然后序列化成字符串形式，然后塞进Redis缓存。 同样，取用户信息经过一次反序列化的过程。 Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。 当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。 这句话：”扩容都是加倍现有空间”。 字符串是由多个字节组成，每个字节又是由8个bit组成，如此便可以将一个字符串看成很多bit的组合，这便是 bitmap(位图) 数据结构。 Jedis提供关于String的操作Java的API有这些：set 12345678910111213141516171819202122/** * 存储数据到缓存中，若key已存在则覆盖 value的长度不能超过1073741824 bytes (1 GB) * * @param key * @param value * @return */String set(String key, String value);/** * 存储数据到缓存中，并制定过期时间和当Key存在时是否覆盖。 * * @param key * @param value * @param nxxx * nxxx的值只能取NX或者XX，如果取NX，则只有当key不存在是才进行set，如果取XX，则只有当key已经存在时才进行set * * @param expx expx的值只能取EX或者PX，代表数据过期时间的单位，EX代表秒，PX代表毫秒。 * @param time 过期时间，单位是expx所代表的单位。 * @return */String set(String key, String value, String nxxx, String expx, long time); String的应用场景1) 存储SQL的某一个字段 把Key值设计为： 表名：主键名：主键值：字段名 1set user:id:1:email:123456@163.com 2)存储对象 String类型支持任何格式的字符串，应用最多的就是存储JSON或其他对象格式的字符串，应用最多的就是存储JSON或其他对象格式化的字符串。(这种场景下推荐使用hash数据类型) 1set user:id:1 &apos;[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;zj&quot;,&quot;email&quot;:&quot;156577812@qq.com&quot;&#125;,&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;zj&quot;,&quot;email&quot;:&quot;156577812@qq.com&quot;&#125;]&apos; 3) 生成自增id 当redis的string类型的值为整数形式时，redis可以把它当做是整数一样进行自增(incr)、自减(decr)操作。由于redis所有操作都是原子性的，所以不必担心客户端连接时可能出现的事务问题。 listRedis的列相当于Java语言的LinkedList，注意它是链表而不是数组。这意味着list的插入和删除操作非常快，时间复杂度为O(1), 但是索引很慢，时间复杂度为O(n). 如果再深入一点，你会发现Redis底层存储的还不是一个简单的linkedlist，而是称之为快速链表quicklist 的一个结构。 首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist , 也是压缩列表。 它将所有的元素紧挨着一起存储，分配的是一块连续的内存。 当数据量比较多的时候才会改成 quicklist。 因为普通的链表需要的附加指针空间太大，会比较浪费时间，而且会加重内存的碎片化。 比如这个列表存的只是int类型的数据， 结构上还需要两个额外的指针 prev 和 next. 所以Redis将链表和 ziplist结合起来组成了 1234// 右进Long rpush(String key, String... string);// 左进Long lpush(String key, String... string); 1234// 左出String lpop(String key);// 右出String rpop(String key); 1List&lt;String&gt; lrange(String key, long start, long end); list数据类型的应用场景1) 消息队列 redis的list数据类型对于大部分使用者来说，是实现队列服务最为经济，最为简单方式。 2) “最新内容” 因为list结构的数据查询两端附近的数据性能非常好，所以适合一些需要获取最新数据的场景，比如新闻类应用的 “最新新闻”。 优化建议：list是链表结构，所以如果在头部和尾部插入数据，性能非常高，不受链表长度影响；但是如果在链表中插入数据，性能就会越来越差。 hashRedis的字典相当于Java语言里面的HashMap，它是无序字典。 内部实现结构上同Java的HashMap也一致。 同样的数组 + 链表二位结构。 第一维 hash的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。 不同的是，Redis的字典的值只能是字符串，另外它们的rehash的方式不一样，因为Java的HashMap在字典很大的时候，rehash是个耗时的操作，需要一次性全部rehash。 Redis为了提高性能，不能堵塞服务，所以采取了渐进方式rehash策略。 渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 操作指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。当搬迁完成了，就会使用新的hash结构取而代之。 hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。 hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。 hash数据类型的应用场景hash 类型很像一个关系型数据库的数据表，hash 的 Key 是一个唯一值，Value 部分是一个 hashmap 的结构。 假设一张表结构如下： 如果要用redis的hash结构存储，数据模型如下： hash数据类型在存储上述类型的数据时具有比string类型更加灵活、更快的优势。使用string类型存储，必然需要转换和解析json格式的字符串，即便不需要转换，在内存开销方面还是hash占优势。 setRedis的集合相当于Java语言里面的HashSet，它内部的键值对是无序的的唯一的，它的内部实现相当于一个特殊的字典，字典中所有的value都是NULL。 set 结构可以用来存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。 set数据类型是一个集合(没有排序，不重复)，可以对set类型的数据进行添加、删除、判断是否存在等操作(时间复杂度O(1)) set集合不允许数据重复，如果添加的数据在set中已经存在，将只保留一份。 set类型提供了多个set之间的聚合运算，如求交集、并集、补集；这些操作在redis的内部完成，效率很高。 set 类型的特点是——不重复且无序的一组数据，并且具有丰富的计算功能，在一些特定的场景中可以高效的解决一般关系型数据库不方便做的工作。 set的应用场景“共同好友列表” 社交类应用中，获取两个人或多个人的共同好友，两个人或多个人共同关注的微博这样类似的功能，用 MySQL 的话操作很复杂，可以把每个人的好友 id 存到集合中，获取共同好友的操作就可以简单到一个取交集的命令就搞定。 12345678910111213141516171819202122232425// 这里为了方便阅读，把 id 替换成姓名sadd user:wade james melo paul kobesadd user:james wade melo paul kobesadd user:paul wade james melo kobesadd user:melo wade james paul kobe// 获取 wade 和 james 的共同好友sinter user:wade user:james/* 输出： * 1) &quot;kobe&quot; * 2) &quot;paul&quot; * 3) &quot;melo&quot; */ // 获取香蕉四兄弟的共同好友 sinter user:wade user:james user:paul user:melo /* 输出： * 1) &quot;kobe&quot; */ /* 类似的需求还有很多 , 必须把每个标签下的文章 id 存到集合中，可以很容易的求出几个不同标签下的共同文章； 把每个人的爱好存到集合中，可以很容易的求出几个人的共同爱好。 */ 12Long sadd(String key, String... member);Long sadd(byte[] key, byte[]... member); zsetzset 可能是 Redis 提供的最为特色的数据结构，它也是在面试中面试官最爱问的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫做「跳跃列表」的数据结构。 zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。 zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。 java: zadd(…) 参数列表如下： 1234567Long zadd(String key, double score, String member);Long zadd(String key, double score, String member, ZAddParams params);Long zadd(String key, Map&lt;String, Double&gt; scoreMembers);Long zadd(String key, Map&lt;String, Double&gt; scoreMembers, ZAddParams params);","categories":[{"name":"Redis","slug":"Redis","permalink":"http://lmwtuedu.cn/categories/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://lmwtuedu.cn/tags/Redis/"}],"author":"LJ"},{"title":"闲说RPC_01","slug":"2018-09-05-闲说RPC_01","date":"2018-09-04T16:00:00.000Z","updated":"2019-09-18T03:13:49.847Z","comments":true,"path":"2018/09/05/2018-09-05-闲说RPC_01/","link":"","permalink":"http://lmwtuedu.cn/2018/09/05/2018-09-05-闲说RPC_01/","excerpt":"","text":"#闲说-RPC_01 我只是一个网络搬运工，客观的归纳整理。 如有侵权，请联系我 环境 Java JDK1.8 IDEA maven 基本原理常言道听的多了就懂了，一老听同事RPC，我本人也懂得一些rpc的用法，例如一些开源框架阿里的dubbo，调度中心的工具zookeeper。 熟练的运用如何操作。通过spring只需简单的配置一些配置，例如： 服务端配置： 1234567891011&lt;dubbo:application name=&quot;xxxxxx-rpc-service&quot;/&gt;&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt;&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20881&quot;/&gt;&lt;!--&lt;dubbo:monitor protocol=&quot;registry&quot;/&gt;--&gt;&lt;!-- 系统 --&gt;&lt;bean id=&quot;xxxSystemService&quot; class=&quot;com.xxxxx.rpc.service.impl.UpmsSystemServiceImpl&quot;/&gt;&lt;dubbo:service interface=&quot;com.xxxxxx.rpc.api.xxxSystemService&quot; ref=&quot;upmsSystemService&quot; timeout=&quot;10000&quot;/&gt; 客户端配置： 123456789&lt;dubbo:application name=&quot;xxx-server&quot;/&gt;&lt;dubbo:registry file=&quot;./xxx-server-dubbo.cache&quot; address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt;&lt;!-- 订阅服务 --&gt;&lt;dubbo:consumer check=&quot;false&quot;/&gt;&lt;!-- 系统 --&gt;&lt;dubbo:reference id=&quot;xxxSystemService&quot; interface=&quot;com.xxx.rpc.api.xxxSystemService&quot; mock=&quot;true&quot;/&gt; 我摘录了一些知乎的关于原理的回答： 知乎rpc解释 摘录RPC：远程调用。通过RPC框架，使得我们可以像调用本地方法一样地调用远程机器上的方法： 1、本地调用某个函数方法 2、本地机器的RPC框架把这个调用信息封装起来（调用的函数、入参等），序列化(json、xml等)后，通过网络传输发送给远程服务器 3、远程服务器收到调用请求后，远程机器的RPC框架反序列化获得调用信息，并根据调用信息定位到实际要执行的方法，执行完这个方法后，序列化执行结果，通过网络传输把执行结果发送回本地机器 4、本地机器的RPC框架反序列化出执行结果，函数return这个结果 作者：Doing链接：https://www.zhihu.com/question/25536695/answer/285844835来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 具体的详细点击链接查看一些人对于原理的解释吧。 归纳知乎的一些回答，提到了一些概念东西，RPC的实现需要： 选择传输协议、协议传输层、注册中心选择。 选择传输协议 高性能的rpc和良好的编码协议是分不开的。好的协议不仅耗用流量小，而且序列化和反序列化更快。现在比较流行的协议thrift、protobuf、json、restful等。其中thrfit和protobuf性能都比较优异，而且占用空间较小，最重要是跨语言，具有语言平台无关性。美中不足就是他们都需要预先根据协议文件预先生成好代码。开发不流畅，但是我们可以自定义协议。像dubbo和motan一样。具体详细百度dubbo和motan 协议传输层 Netty框架不局限于rpc，更多的是作为一种网络协议的实现框架，例如HTTP，由于RPC需要高效的网络通信，就可能选择以Netty作为基础。 Netty提供异步的、事件驱动的网络应用程序架构和工具，用以快速开发高性能、高可靠的网络服务器和客户端程序。目前使用netty作为传输层的rpc框架有很多，例如dubbo motan等 注册中心的选择 现在有很多提供服务注册发现的服务，实现成本比较低的就是zookeeper，可以很容易的实现服务注册和服务发现的功能。 结束 以上都是对RPC的一些原理的一些东西的解释。接下来就请查看我基于一份别人写的开源项目，去剖析RPC的一些实现东东吧。具体详细见：闲说-RPC（二） 一个流浪的码农，小主赏赐一口饭吃～","categories":[{"name":"framework","slug":"framework","permalink":"http://lmwtuedu.cn/categories/framework/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"http://lmwtuedu.cn/tags/rpc/"}],"author":"LJ"},{"title":"学习架构参考","slug":"2018-08-29-学习参考设计架构","date":"2018-08-28T16:00:00.000Z","updated":"2019-09-17T08:19:21.179Z","comments":true,"path":"2018/08/29/2018-08-29-学习参考设计架构/","link":"","permalink":"http://lmwtuedu.cn/2018/08/29/2018-08-29-学习参考设计架构/","excerpt":"","text":"##学习参考设计架构 在此收集的支付宝的系统架构图包含：清算、客服、处理、资金、财务等等，由于资料年限限制，仅供参考，但基本架构相信还是变化不大的。作为支付行业的龙头，架构系统值得学习！","categories":[{"name":"framework","slug":"framework","permalink":"http://lmwtuedu.cn/categories/framework/"}],"tags":[{"name":"framework","slug":"framework","permalink":"http://lmwtuedu.cn/tags/framework/"}],"author":"LJ"},{"title":"爆雷之后 中产惊惶","slug":"2018-08-06-爆雷之后 中产惊惶","date":"2018-07-25T16:00:00.000Z","updated":"2019-09-17T08:18:56.538Z","comments":true,"path":"2018/07/26/2018-08-06-爆雷之后 中产惊惶/","link":"","permalink":"http://lmwtuedu.cn/2018/07/26/2018-08-06-爆雷之后 中产惊惶/","excerpt":"","text":"爆雷之后 中产惊惶昏暗的灯光下，程⽣在电脑前跟各地难友沟通。他在杭州拱墅区的一所廉价宾馆已经住了20多天，每天所做的事就是想尽各种办法把自己的本金讨回。 财富小镇P2P平台的这一串爆雷，撕破了脆弱的中产幻觉。他们不仅损失了百万投资，体面和尊严也突然成了奢侈品。 7月25日，杭州的温度高达37度。苏州的家庭主妇李霞、广州的创业者程生、湖南的大学生张颖以及北京的保姆张彩娥，以一种怪异的方式，聚集到京杭大运河附近一家廉价旅馆。 他们自称P2P爆雷潮中的‌‌“难民‌‌”，在过去的一两年内，将家庭或个人的所有积蓄，2万到100万不等，投入到了杭州号称服务新中产的P2P平台投融家。让他们猝不及防的是，平台突然爆雷了。过去几天里，他们顶着烈日或午后忽然而至的暴雨，像无头苍蝇一样，奔走于杭州各个区，寻找追回财产的任何一丝可能性。 他们好像什么都有，但丧之也不过一夜之间。数以万计家庭的数十亿财富，突然蒸发，所有人被生活抛到了从未到达的境地。很多人从没想过自己会与维权扯上关系，体面和尊严突然成了奢侈品。 突如其来的爆雷 李霞是从苏州到了杭州后，才知道‌”爆雷‌‌“这个词的，‌‌”感觉天都塌了‌‌“。回忆起爆雷当天的情形，她情绪依然激动。这个家庭主妇可能是最早发现平台不对劲的投资者之一。7月9日那天是周一，早餐之后，丈夫去上班，女儿放暑假在家玩iPad，她例行打开投融家APP查看投资的情况，却发现登陆界面出现闪退。 这是过去不曾有的情形。李霞一直很放心投融家，自2016年7月接触以来，平台的任何异动都会提前发布公告。‌‌”这次没有任何通知，平台突然变得不稳定，这很不正常。‌‌“ 押注了家庭的全部积蓄以及父母的10万公积金，平台的任何风吹草动都能引起李霞的警觉。她马上翻到在线客服页面，打算咨询客服。 客服界面也出现了异常。理应是工作时间，对话框却挂出一行红字：‌‌”当前无客服在线。客服工作时间：工作日09：0021：00 非工作日09：0017：30‌‌“。李霞心里咯噔了一下，立即拨打客服热线。 400开头的电话始终无人接听。中午，下午，晚上，她重复了多次。一夜辗转反侧，次日清晨，李霞重拨时，听筒里传来了冰冷的提示——‌‌”您所拨打的电话号码已被注销‌‌“。‌‌”这么快就把客服电话就注销了，公司跑路了？‌‌“李霞意识到出了问题，整个人慌了神。 余额不能提现，到期的标的没有回款，客服电话无人接听。分布在各地的投资者此前并无任何沟通渠道，APP内的投友交流区突然变成了投资客们的维权联络区。一些人踊跃建群，希望收集更多的公司信息。有人回忆，自己在7月5日还有回款，但只提出了利息，只差了几天就能避开雷区；也有人反映，7月6日投的标的没能成功生成合同。投融系另一款产品多多理财的员工，7月9日在多多理财官网上发出消息，称多多理财失去控制，员工被拖欠工资社保，引导投资人报警。 种种迹象指向了公司崩盘。 有投资者坐不住，直接飞到了投融家总部所在地杭州，其中包括浙江衢州的程生和女友。 7月9日，程生的女友在投融家平台购买的十几个标的里，正好有一个当天到期。往常标的到期后，本金和收益都会在上午九点返到个人账户，但那天到了下午，账户依然毫无动静。半个月来的奔波和睡眠不足，在程生脸上留下了大大的黑眼圈。30岁的程生做过服装批发生意，两年前转辗到广州，目前正在创业，100万元几乎是他们能拿出的全部积蓄。‌‌”她一提到这事就哭，我也是爆雷后才知道投入这么大。‌‌“程生说。 他们到杭州后，立马赶往投融家的办公室。它位于杭州市拱墅区财富小镇的核心位置，投融家所关联的投融长富集团占据了一栋大楼的12~17层，从楼梯的窗户远眺，能看到千年川流不息的京杭大运河。历史上，运河曾给杭州带来了源源不断的财富。 7月9日傍晚，程生在这里看到的却是一片混乱。办公室空无一人，A4纸印的各类文件撒了一地，办公桌抽屉大开，饮料瓶和各种杂物到处都是。守了半天一无所获后，他只好去派出所报案。接下来的几天，投融长富涌来了来自全国的投资者，等着他们的除了紧锁的办公室，只剩下还没来得及撤走的公司宣传用易拉宝。红色的展板一派喜庆，上面还在庆祝6月份公司业绩破100亿。 投融系前理财经理冯佳觉得最残酷的是，赔了的不只是自己的钱。父母、朋友和客户的钱都套进去了，这让她背负了巨大的道德压力。‌‌”我觉得我没法再过好了‌‌“，冯佳这些天里瘦了7斤。杭州7月的气温天天在36度以上，她却时不时会打个寒颤。 她是金融行业的老人。2011年互联网金融行业刚刚起步时，她开始从业，自认对选公司和选产品都很谨慎，‌‌”当初E租宝想招我，我一看他们一天内更新的借款人数量就觉得不靠谱，哪里来这么多人要借钱呢。‌‌“冯佳告诉别人，自己避开过不少坑。 一年前，冯佳任职于投融系旗下的某家子公司，并逐步买入了一些公司的产品，父母的养老金加上自己的存款，总计投入95万元。当时，一些亲戚朋友和客户向她咨询过理财产品，最终通过她购买了投融系的理财产品，总额有好几百万元。 7月9日一早，一位老客户告知她，投融长富旗下的一款产品本该当天到期，却未收到本息。她一惊，转身就致电前同事，对方告诉她，‌‌”老板联系不上了‌‌“。电话挂断后，冯佳浑身发软。朋友开车送她回家，下车时她双腿使不上劲，摔了一跤。半个多月里，冯佳时不时感到一阵恍惚，总忍不住拍打手臂确认自己不是在做梦，‌‌”我不敢相信这一切会发生在我的身上‌‌“。 也有人在7月9日这天毫无知觉。杭州本地人武连是在13日才得知爆雷消息，他投过9个平台，投融家是爆雷的第一家。‌‌”投融家注册用户有145万，现在知道的受害者据说有几万人，还有些标没有到期的人，估计还不知道投融家已经爆雷了。‌‌“李霞说。 不少人从外地赶赴杭州，‌‌”我死也要死个明白‌‌“。‌‌”从前我来杭州是来旅游的，现在变成了到处被人赶。‌‌“李霞也带着女儿走上了维权讨债之路。他们在盛夏的杭州像无头苍蝇一样，挤在廉价旅馆里等着消息，一有消息，立即赶到可能会带来转机的现场。 慢慢建立的信任 ‌‌”信任崩塌了，还有什么能相信呢？‌‌“李霞经常越说越激动，突如其来的P2P违约雷暴让很多人产生了幻灭感。 许多人经常被追问，为什么要把身家性命押注到一家互联网金融平台上。‌‌”我就是信任它呀‌‌“，几乎所有投资者都用信任来解释自己的投资行为。 李霞是从一个公众号的推荐中知道了投融家的存在，像她一样加入维权行列的武连则是从杭州本地的电台节目交通91.8上知道了它。他们都再三强调了投融家背后的上市公司投融长富的背景，认为这让公司的抗风险能力更高，产品更规范。 李霞认为自己已经非常谨慎了。她两年前开始投资投融家产品，和多数投资者一样，最初额度都很小，几千块试水，周期不长，密切留意平台的到账时间。两年来，产品回款及提现几乎是秒到账。‌‌”非常准，就慢慢信任它了。‌‌“ 套路玩法1：初步建立信任，秒到账，周期短，慢慢建立信任链 投融家平台非常注意对用户的运营和维护。2017年2月正值农历新年，李霞收到了投融家发来的包裹，里面是一个紫砂保温杯。‌‌”一周年时给投资者送的小礼品，公司有这个文化还挺用心的。‌‌“她没有用过那个紫砂保温杯，却因此对投融家的信任度更高了。 套路玩法2:对用户邮寄小的礼物，杯子、公仔、键盘、鼠标、鼠标垫、行李箱、背包、剃须刀； 此套路常常出现在生活中，办理信用卡上。 人都是需要被爱的，进一步建立此公司满靠谱，挺用心的。 她还留意到，平台经常会提前几天发出服务器运维的公告，包括某些银行充值或提现的服务指引公告。这些细节让她形成了一个印象：投融家在意用户的感受，平台的可控性高，不会无缘无故出问题。李霞的投资额度越来越大，时间周期也逐渐变长，最终她把父母的十几万存款与自己十几年的积蓄都放了进去。 套路玩法3: 公告指示：引导用户一些操作，基本操作技能，在乎用户体验，让用户感受可控性高 有人相信自己是拿到了内幕消息的。程生的女友是金融从业者，有位朋友是杭州某家银行的管理层，‌‌”他自己买了，然后推荐给我们‌‌“。在这种微妙的类似内幕消息的心理暗示下，程生家里的现金陆续被放进了投融家。‌‌”其实她也希望分散一下风险，所以分成了十几个标，在不同的时间段买的。‌‌“程生认为，一旦相信了这个平台，投一半和投全部几乎没有区别，有闲钱了就投。 套路玩法4: 所谓的“内幕消息”，公司职员购买公司产品，金融从业者，高管～～， “听起别人的推荐” 一口相传，朋友推荐，这样比自己推销更可靠～～ 武连也以为自己站在了安全警戒线内。他是本地人，有各种消息渠道，一些信息和迹象让他相信，这是家‌‌”跟上面关系很好‌‌“的公司。在投融家的公众号上，政府官员考察的信息被当做新闻推送，像武连这样的投资者将之视作政府的背书。 套路玩法5: 跟所谓的“关系” 政府搞好关系，当地媒体推送，以及媒体的传播～～ 借助外部优秀的形象包装自己，如上市公司，靠山央企，国家保障～～ 维权者中，还有一些本不具备投资知识的人‌‌”听了高档人的建议‌‌“，也杀了进去。张彩娥瞒着家人赶到了杭州，她家在河南，在北京做家政，在投融系平台总共投了十五万元。2017年儿子买车想要钱，她没给，想再多存点，‌‌”如果是低档人说的，我可能就不投了‌‌“。 套路玩法6: “高档人推荐”， 眼红所谓别人的利益，都想去从中分一杯羹，就好比撸羊毛的策略～ 也有人觉得自己做足了功课，是理性投资者。张颖刚满20岁，还在念大三，自己打工存下了两万多元。她考过证券从业资格证、投资顾问证，还打算考CPA。投资之前，她仔细比较了一些机构给各个网贷平台的打分，最终挑选了收益率相对安全、分数在前30的投融家。‌‌”我避开了很多雷，从来没想到还会被坑。‌‌“张颖在几天的时间里脸上长了不少痘痘，她没告诉家人这一切，唯一庆幸的是自己还没毕业没有更多钱来投资。 套路玩法7: 我以为我避开了很多雷区，其实下一步就是‘深渊’。 资深从业者冯佳相信自己看公司的眼光，‌‌”我会用安全感来形容那个时候的公司。‌‌“她还记得投融长富2017年9月入驻拱墅区财富小镇时公司意气风发的场景。当时，新的办公室在特色小镇中心位置，五层里有一层据说要开辟为咖啡厅，专门接待各路投资者。办公区显眼的位置，有一面墙全部是投融系公司获得的奖杯和勋章，董事长在台上演讲，踌躇满志，一切看上去欣欣向荣。 ‌‌”看到那一切，我觉得老板是一个非常想干实事的人，一切才刚刚开始。‌‌“她觉得即使未来有风险也应该能撑四五年，所以投了两年期的产品，也向朋友和家人介绍了一些产品。 套路玩法8: 这让我突然想到了，中国的贾老板。 会做PPT的大佬，以及会开发布会的大佬 杭州人王淑珍的境遇类似于冯佳的客户和朋友。她听说业务员自己也购买了投融家产品，‌‌”业务员自己也买了，开车接送我，对我很好。‌‌“68岁的王淑珍认为，业务员总不可能买亏，于是放心地分三次总计投入了70万元。 来自亲友的推荐、内幕消息、一些互金公司指数排行、上市公司的光环、地方政府背书甚至对自身投资能力的自信，都是投资者选择某家P2P平台的理由。 一些投资者会拿P2P平台和余额宝作对比，收益率被再三提及。他们不认为自己是在赌博，觉得理性的投资应该被保护。‌‌”余额宝的收益也有过百分之六七，我们比余额宝高不了多少的，没有超过行业水平的。‌‌“投融家平台上标的7%~9%之间的收益率，偶尔做活动，加赠1%的收益，但这种情况极少。 保护： 你所谓的保护，其实我想呵呵，亏吃了，你就要认； 出来混，迟早要还～～ ‌‌”如果收益率超过15%，我肯定不敢投了。‌‌“李霞说。过去几年里，银行储蓄贬值几乎是人尽皆知的事，有人反问了一句，‌‌”除了P2P我们还能投资什么？‌‌“ 毫无征兆的倒塌？ 整个家庭十几年的积蓄被自己投到了一个P2P平台，虽然能归结为信任。但这群投资者有一个无法面对的问题。 ‌‌”你怪自己吗？‌‌“ 坐在旅馆床上的李霞听到这句话，情绪突然失控。她双手掩面，抽泣起来。‌‌”怎么能不怪自己，我本来什么都有，有房有车，现在怎么弄成这样，像个难民。‌‌“她抽噎着，肩膀不能自制地颤动，她的女儿就在隔壁房间，高烧刚刚退去。前一天晚上，她们住的廉价旅馆大床房里挤了八九个人，地毯上铺着几床被子，桌子上放着早晨没吃完的咸菜和包子。窗外阳光热辣，但不远处能看到一团乌云，盛夏的暴雨正在酝酿。 难友抱团维权，为了节约成本他们多人合住。最高时一个房间住着9个人，分摊每人几十元的房费，只希望能等到最好的消息。 一切真的毫无征兆吗？逐渐平静之后，李霞开始回想整个事情的经过，想起了被她疏忽的蛛丝马迹。 年初，丈夫留意到监管收紧，提醒李霞注意风险，但没有引起她的警觉。6月初，投融家在APP中发布了一则诱人的活动：‌‌”跨越百亿，感恩加息1%‌‌“（简称‌‌”跨百亿‌‌“）。愚人节前后，它的交易额刚刚突破90亿。‌‌”跨百亿‌‌“推出之后短短一周之内，平台吸收资金超10亿。因为加息的诱惑，李霞非但没有将到期的20万元提现，反倒追投了20万元。 套路玩法9: 监管加紧，最后收割一波，贪念往往是最好的诱饵，所以感恩加息1% ‌‌”跨百亿‌‌“期间，‌‌”迷局‌‌“已经露出端倪。例如，平台上突然涌现出许多标的，随时都可以投标。此前，这是不可想象的事。通常情况下，平台每天只有两次抢标的时间，类似于准点秒杀，有些标的一经挂出，几分钟内就会被‌‌”秒光‌‌“。 李霞恍然发现，不知道从什么时候开始，自己已经不再看任何标的合同，不知道借款人是谁，也不知道借款的原因。但是，在小额试水初期，原本从事行政工作的她会悉心研究每次投标的合同细则，评估项目风险。 优秀的习惯，需要长期保持，别让利益或者时间的流逝，慢慢蒙蔽了双眼，最后可能是压死自己的一根稻草；其实常常我们注册一些东西，或者一些关于利益的，我们都没有好好读过～～ 出事之后，李霞才仔细查看了标的内容——几乎都是关于净水器的，这令她感到不可思议。净水器几乎成了一个梗，杭州拱墅区小河派出所门口，维权的投资客们彼此打招呼时会问，‌‌”你也买了净水器？‌‌“ 6月底，投融家平台上演了荒诞的一幕，包括教师、会计、工程师、家庭主妇、保姆等成千上万人，一周之内砸10亿资金，疯狂投资净水器。‌‌”标的极有可能是假的，投融家在自融，试想想，谁需要买那么多净水器？‌‌“李霞懊丧地说。 投资者们没有察觉的风险预警并不少。 投融家‌‌”跨百亿‌‌“活动开始那天，小米推荐的车贷平台‌‌”小灰熊金服‌‌“宣告清盘；此前3天，河南的P2P平台金牌理财发布停业公告。闷雷滚滚，没有人觉得他人的不幸与自己有关。 6月11日，在投融长富的总部大楼里，投融家为交易额破百亿举办了一场庆祝会，CEO在内的高管悉数到场，并邀请了两位投资人，他们代表了多数中产家庭，从小额开始，缓慢建立信任，最终重仓投融家。在各色蛋糕、曲奇、水果和鲜榨果汁的甜美香气里，投融长富副总裁付奇打了一手温情牌：‌‌”这是一次家庭的聚会。‌‌“这些信息都通过微信公众号与APP传递给了投资人——我们平台一切都好。 另一个被投资者频繁提及的障眼法是‌‌”备案‌‌“。在投融家APP中较显眼的位置，至今还放着一则宣传信息，公司正在进行一项覆盖整个行业的P2P网络借贷备案。这种资质背书，让李霞和程生们觉得又给平台上了一重保险，让平台变得更规范了。 不停的加码的同时，不停的给用户打安定剂，稳定用户，准备跑路；玩法很简单，但是… 但实际上，早在6月14日，多家主流媒体报道，整个行业原本定于6月底前完成的P2P网络借贷备案工作已整体后延。中国银行保险监督管理委员会普惠金融部主任李均锋曾在‌‌”第十届陆家嘴论坛‌‌“接受采访时表示，整个行业的备案工作年内可能不能完成。 投融家爆雷至今，程生等人都不知道公司备案的具体情况，也没有细致去了解过实际情况。到爆雷之时，投资者们始终相信平台融资额增加会有利于备案工作的完成。‌‌”（在当时）我们甚至产生与平台共进退的荣誉感。‌‌“程生情绪有些复杂。 整个行业的沉疴也成了不理性投资孳生的土壤。P2P和各类理财平台狂飙猛进的那几年，作为身在其中的员工，冯佳甚至感觉到有些触目惊心，‌‌”任何投资都有风险，但我无法向客户提示风险。‌‌“她刚入行的时候，互金公司会对销售人员进行产品风险培训，在客户沟通阶段也会提示风险。‌‌”但实际情况是，理财经理一说风险，客户掉头就走，这就是国人的理财心理。‌‌“ 现实教育了冯佳，大部分的理财者都没有理性的预期，‌‌”他们只接受稳赚不赔，本息一样都不能少。‌‌“长此以往，为了客户留存，几乎所有平台的理财经理都不再提示潜在的风险。 在一些理财顾问那里，投资者已经习惯把自己的积蓄全盘托付，坐在家里，等待每月的利息如期到账。像冯佳一样的理财顾问们，也习惯了用‌‌”没问题‌‌“‌‌”我自己也投的，比较稳‌‌“来告知风险。风险是个概率事件，只要它未曾发生，它仿佛就不存在。在大部分的理财平台上，风险提示的埋点都特别深，投融家平台的设置也是如此。 酒店里挂着一件印有‌‌”还钱‌‌“两字的t恤，全国各地的难友制作了200件衣服以此得到有关部门重视，但似乎没有得到效果。 一些维权的投资者遇到对风险的疑问时，语气会变得急促。‌‌”我是和平台发生交易，就算看了也没有用，责任在平台。‌‌“说这话时，一位投资者语速加快，声音提高。与之相矛盾的是，和大部分的投资者一样，她知道P2P理论上只是信息中介。 ‌‌”疏忽‌‌“的的确不止李霞一人。王淑珍在杭州一栋老式居民楼里摊开总计70万元的3份合同时，眼睛几乎要眯成一条缝才能艰难找到转账记录。‌‌”我看不清合同上的字‌‌“，王淑珍认为，她签订的合同等同于高一点利息的银行定存。细如蝼蚁的字号对她已经是不小的障碍，名目繁杂的条例她则根本没有打开看过。 看似毫无征兆的倒塌，可能更是一场缓慢的‌‌”合谋‌‌“。在通胀、孩子教育投入、养老医疗等压力的裹挟下，许多人前赴后继地将自己的半生积蓄投进了P2P。他们如温水煮青蛙般，逐渐放松警惕并日益‌‌”疏忽‌‌“，怀抱微妙的自欺与侥幸心态，如同在浓雾的夜晚开车，被扑朔迷离的光亮迷惑，最终走向了盛夏的雷暴。 “合谋”： 通货膨胀， 教育投入， 养老的医疗， 房产的上涨～～。温水煮青蛙，自欺以及侥幸心态 被打乱的生活，被打醒的中产幻觉 李霞和程生都还在杭州的廉价旅馆里捱日子。他们住的房间已经从9楼搬到7楼。7层的墙壁被涂成了玫粉色，部分墙灰已经剥落，午后阳光斜射进来的时候，甬道就像血色洞窟。 程生的心情已经逐渐平复下来。他的100万元投入里，有50万元要在9月用来偿还此前的贷款，他的女友时常因为自责而情绪崩溃。为了缓解她的压力，程生经常汇总各类信息，这也让他成了从各地赶来杭州的‌‌”难友‌‌“们某种程度上的精神支撑。 但对未来能做什么，他也没有明确的计划，‌‌”只能走一步看一步‌‌“。两天前，程生与女朋友商定，如果一切途径都走不通，就一起徒步去色达。‌‌”求人不行，求己不行，那就只能求佛了。‌‌“他还算年轻，喜欢徒步，生活的一记惊雷他仿佛还熬得住。 对家里有老有小的李霞而言，这一切撕开了脆弱的中产幻觉。正值暑假，李霞的一天本应该是规律又有点单调的。早晨给老公做早餐，上午辅导女儿做作业，下午再带着孩子画画，晚上十点多就能睡觉。她几乎把基础生活支出之外的储蓄，全部投入投融家，稳定的回款曾给她带来安全感。 财富在自己手中才是安全感，我命由我，不由天～ ‌‌”爆雷‌‌“后，李霞带着女儿来到了杭州，本来正在旅游的他们发生了意外，生活轨迹发生了变化。 现在一切都乱了。那40万元里除了父母的养老金，还有要给孩子报英语班、画画班的钱。‌‌”全家只有我丈夫一人上班，本来想给孩子报个钢琴班，现在也只能压缩这些计划了。‌‌“她每天只顾得上在各个群里探听各种消息，没有心力给孩子辅导作业，小女孩经常一个人被留在宾馆看动画片。 她还担心热度消退，像此前所有新闻热点一样，最终不了了之。她不希望同伴决心动摇，甚至不愿意一起行动的伙伴将不利于维权的信息告诉身在外地的人。‌‌”这么突然的财产蒸发，也没有人管这样的平台，影响的都是中间阶层，会出事的。‌‌“李霞有点咬牙切齿。 冯佳也有了改变。‌‌”我之前觉得自己很独立‌‌“，她自诩独立女性，按照自己的意志生活，收入可观，喜欢旅行。她钟情于小城清迈，那是邓丽君去世的地方。‌‌”现在觉得这就是一场中产的幻觉。‌‌“ 她希望自己能好好哭一场。为了缩减开支，她可能没法再住在现在的房子，投融系之后干了近一年的工作也丢了。上司知道她此前的公司爆雷，没说别的，只问她，‌‌”你还能在这行做吗？你打算怎么做？‌‌“ 她的确对自己产生了怀疑。‌‌”不只是从业背景有污点的问题，而是客户的钱砸在里面了，这意味着我七年攒的资源都没有了。‌‌“ 从7月9日知道消息，到真正报警，冯佳拖了十天。她花了三天才给所有投资了的朋友客户打完电话，每次打电话前要做很久的心理准备，经常讲到一半，整个人情绪崩溃。 她不愿意立即报警，也尽量压着客户朋友别太早报警。‌‌”逾期和提现困难有时候是正常的，如果投资人施压过多，老板跑路，才是致命的问题。‌‌“那几天，她把自己关在家里，不放过任何一点信息，‌‌”每天都在想，老板是去找钱了，也许平台还能运转，也许还有转机。脑子里时刻都在上演一部连续剧。‌‌“她甚至产生过一种自私的期望，平台只要撑过10月份，她就可以拿回自己和客户朋友们的钱。7月20日，她得知投融长富的老板李振军早在7月初就已出境，这才彻底死心。 在咖啡馆里，冯佳斩钉截铁地说：‌‌”我不再那么相信自己的专业、能力，甚至根本不知道还可以相信什么。‌‌“她开始怀疑自己能否独自应对生活的风险，‌‌”也许我该去找个人结婚生子了。‌‌“ 这场风暴对中产以下家庭的打击，也许更为致命。王淑珍生活节俭，闷热的夏夜依然舍不得开空调，见我们时，桌上的饭菜散发出了异味。她的家庭本已危机四伏。大儿子还在殡仪馆，八月份墓地才能安置妥当。年过三十的小儿子至今未婚，多年的积蓄被她砸进理财产品。她原本指望到期之后取现，将一家人住的老房子装修一下，但现在一切都是泡影。 王淑珍把一生的积蓄70万，全投资到投融系的产品里，如今已经血本无归。如果不是该公司的员工一直的推荐和心软地签了合同，这波爆雷潮可能就与她无关。 维权群里，不时有‌‌”更惨‌‌“的消息传来：有人因此离了婚，有人中风了，有人举债加杠杆投资，据说还有人挪用了公款…… 截至7月30日，有媒体统计传出爆雷的P2P平台超过250家，以投融家为例注册用户规模在145万人，目前影响人数数万人，这场盛夏的雷暴影响的人数难以预估。 7月底的黄昏时分，财富小镇华灯初上，远洋大厦楼前几百米的位置，音乐喷泉已经升起，新中产家庭的夜生活刚刚开始。商场橱窗里摆出新一季的服装，咖啡很香，蛋糕很甜，音乐时髦又愉快。挂着‌‌”投融长富‌‌“四个字的招牌，已不再亮灯，相较于周边的大厦有点黯淡失色。 冯佳坐在喷泉前的石凳上茫然看着欢闹的人群，‌‌”我已经不是三周前的那个我了。‌”对身陷其中的人而言，这场遭遇是一场大考。而广场中心，嬉闹的孩子正不顾一切冲进喷泉中。往来的人们正享受着繁荣的都市生活，他们对几百米外正发生的雷暴一无所知。 国人思想：事不关己，高高挂起～～ 其实都是有点可悲的，包括我们自己 （文中人物皆为化名）https://botanwang.com/articles/201808/%E7%88%86%E9%9B%B7%E4%B9%8B%E5%90%8E%7C%E4%B8%AD%E4%BA%A7%E6%83%8A%E6%83%B6.html","categories":[{"name":"article","slug":"article","permalink":"http://lmwtuedu.cn/categories/article/"}],"tags":[{"name":"news","slug":"news","permalink":"http://lmwtuedu.cn/tags/news/"}],"author":"徐婷冯海泳王波"},{"title":"ELK搭建实时日志分析平台","slug":"2018-07-26-ELK(ElasticSearch, Logstash, Kibana)搭建实时日志分析平台","date":"2018-07-25T16:00:00.000Z","updated":"2019-09-17T08:18:36.180Z","comments":true,"path":"2018/07/26/2018-07-26-ELK(ElasticSearch, Logstash, Kibana)搭建实时日志分析平台/","link":"","permalink":"http://lmwtuedu.cn/2018/07/26/2018-07-26-ELK(ElasticSearch, Logstash, Kibana)搭建实时日志分析平台/","excerpt":"","text":"ELK(ElasticSearch, Logstash, Kibana)搭建实时日志分析平台在搜索ELK资料的时候，发现这篇文章比较好，于是摘抄一小段：以下内容来自：http://baidu.blog.51cto.com/71938/1676798 日志主要包括系统日志、应用程序日志和安全日志。系统运维和开发人员可以通过日志了解服务器软硬件信息、检查配置过程中的错误及错误发生的原因。经常分析日志可以了解服务器的负荷，性能安全性，从而及时采取措施纠正错误。通常，日志被分散的储存不同的设备上。如果你管理数十上百台服务器，你还在使用依次登录每台机器的传统方法查阅日志。这样是不是感觉很繁琐和效率低下。当务之急我们使用集中化的日志管理，例如：开源的syslog，将所有服务器上的日志收集汇总。集中化管理日志后，日志的统计和检索又成为一件比较麻烦的事情，一般我们使用grep、awk和wc等Linux命令能实现检索和统计，但是对于要求更高的查询、排序和统计等要求和庞大的机器数量依然使用这样的方法难免有点力不从心。开源实时日志分析ELK平台能够完美的解决我们上述的问题，ELK由ElasticSearch、Logstash和Kiabana三个开源工具组成。官方网站：https://www.elastic.co/products • Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。 • Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。 • Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。 —————————-摘抄内容结束——————————- ELK平台搭建 系统环境 12345System: Centos release 6.7 (Final)ElasticSearch: 2.1.0Logstash: 2.1.1Kibana: 4.3.0Java: openjdk version &quot;1.8.0_65&quot; 注：由于Logstash的运行依赖于Java环境， 而Logstash 1.5以上版本不低于java 1.7，因此推荐使用最新版本的Java。因为我们只需要Java的运行环境，所以可以只安装JRE，不过这里我依然使用JDK，请自行搜索安装。 ELK下载：https://www.elastic.co/downloads/ ##ElasticSearch配置ElasticSearch： 12tar -zxvf elasticsearch-2.1.0.tar.gzcd elasticsearch-2.1.0 安装Head插件（Optional）： 1./bin/plugin install mobz/elasticsearch-head 然后编辑ES的配置文件： 1vi config/elasticsearch.yml 修改以下配置项： 1234cluster.name=es_clusternode.name=node0path.data=/tmp/elasticsearch/datapath.logs=/tmp/elasticsearch/logs #当前hostname或IP，我这里是centos2 12network.host=centos2network.port=9200 错误修改 正确示范： 其他的选项保持默认，然后启动ES： 1./bin/elasticsearch 启动提示错误时： 可以看到，它跟其他的节点的传输端口为9300，接受HTTP请求的端口为9200。使用ctrl+C停止。当然，也可以使用后台进程的方式启动ES： 1./bin/elasticsearch &amp; 然后可以打开页面localhost:9200，将会看到以下内容： 返回展示了配置的cluster_name和name，以及安装的ES的版本等信息刚刚安装的head插件，它是一个用浏览器跟ES集群交互的插件，可以查看集群状态、集群的doc内容、执行搜索和普通的Rest请求等。现在也可以使用它打开localhost:9200/_plugin/head页面来查看ES集群状态： 可以看到，现在，ES集群中没有index，也没有type，因此这两条是空的。 LogstashLogstash的功能如下： 其实它就是一个收集器而已，我们需要为它指定Input和Output（当然Input和Output可以为多个）。由于我们需要把Java代码中Log4j的日志输出到ElasticSearch中，因此这里的Input就是Log4j，而Output就是ElasticSearch。配置Logstash： 12tar -zxvf logstash-2.1.1.tar.gzcd logstash-2.1.1 编写配置文件(名字和位置可以随意，这里我放在config目录下，取名为log4j_to_es.conf)： 12mkdir configvi config/log4j_to_es.conf 输入以下内容： 1234567891011121314151617181920212223# For detail structure of this file# Set: https://www.elastic.co/guide/en/logstash/current/configuration-file-structure.htmlinput &#123; # For detail config for log4j as input, # See: https://www.elastic.co/guide/en/logstash/current/plugins-inputs-log4j.html log4j &#123; mode =&gt; &quot;server&quot; host =&gt; &quot;centos2&quot; port =&gt; 4567 &#125;&#125;filter &#123; #Only matched data are send to output.&#125;output &#123; # For detail config for elasticsearch as output, # See: https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html elasticsearch &#123; action =&gt; &quot;index&quot; #The operation on ES hosts =&gt; &quot;centos2:9200&quot; #ElasticSearch host, can be array. index =&gt; &quot;ec&quot; #The index to write data to, can be any string. &#125;&#125; logstash命令只有2个参数： 因此使用agent来启动它（使用-f指定配置文件）： 1./bin/logstash agent -f config/log4j_to_es.conf 到这里，我们已经可以使用Logstash来收集日志并保存到ES中了，下面来看看项目代码。Java项目照例先看项目结构图： pom.xml，很简单，只用到了Log4j库： 12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties，将Log4j的日志输出到SocketAppender，因为官网是这么说的： 123456789101112131415161718log4j.rootLogger=INFO,console# for package com.demo.elk, log would be sent to socket appender.log4j.logger.com.demo.elk=DEBUG, socket# appender socketlog4j.appender.socket=org.apache.log4j.net.SocketAppenderlog4j.appender.socket.Port=4567log4j.appender.socket.RemoteHost=centos2log4j.appender.socket.layout=org.apache.log4j.PatternLayoutlog4j.appender.socket.layout.ConversionPattern=%d [%-5p] [%l] %m%nlog4j.appender.socket.ReconnectionDelay=10000# appender consolelog4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.target=System.outlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=%d [%-5p] [%l] %m%n 注意：这里的端口号需要跟Logstash监听的端口号一致，这里是4567。 特别注意：工程的包名称 Application.java，使用Log4j的LOGGER打印日志即可： 12345678910111213package com.demo.elk;import org.apache.log4j.Logger;public class Application &#123; private static final Logger LOGGER = Logger.getLogger(Application.class); public static void main(String[] args) throws Exception &#123; for (int i = 0; i &lt; 10; i++) &#123; LOGGER.error(&quot;Info log [&quot; + i + &quot;].&quot;); Thread.sleep(500); &#125; &#125;&#125; 用Head插件查看ES状态和内容运行Application.java，先看看console的输出（当然，这个输出只是为了做验证，不输出到console也可以的）： 再来看看ES的head页面： 切换到Browser标签： 单击某一个文档（doc），则会展示该文档的所有信息： 可以看到，除了基础的message字段是我们的日志内容，Logstash还为我们增加了许多字段。而在https://www.elastic.co/guide/en/logstash/current/plugins-inputs-log4j.html中也明确说明了这一点： 上面使用了ES的Head插件观察了ES集群的状态和数据，但这只是个简单的用于跟ES交互的页面而已，并不能生成报表或者图表什么的，接下来使用Kibana来执行搜索并生成图表。 ##Kibana配置Kibana: 123tar -zxvf kibana-4.3.0-linux-x86.tar.gzcd kibana-4.3.0-linux-x86vi config/kibana.yml 修改以下几项（由于是单机版的，因此host的值也可以使用localhost来代替，这里仅仅作为演示）： 1234server.port: 5601server.host: “centos2”elasticsearch.url: http://centos2:9200kibana.index: “.kibana” 启动kibana： 1./bin/kibana 用浏览器打开该地址： 为了后续使用Kibana，需要配置至少一个Index名字或者Pattern，它用于在分析时确定ES中的Index。这里我输入之前配置的Index名字applog，Kibana会自动加载该Index下doc的field，并自动选择合适的field用于图标中的时间字段： 点击Create后，可以看到左侧增加了配置的Index名字： 接下来切换到Discover标签上，注意右上角是查询的时间范围，如果没有查找到数据，那么你就可能需要调整这个时间范围了，这里我选择Today： 接下来就能看到ES中的数据了： 执行搜索看看呢： 点击右边的保存按钮，保存该查询为search_all_logs。接下来去Visualize页面，点击新建一个柱状图（Vertical Bar Chart），然后选择刚刚保存的查询search_all_logs，之后，Kibana将生成类似于下图的柱状图（只有10条日志，而且是在同一时间段的，比较丑，但足可以说明问题了：) ）： 你可以在左边设置图形的各项参数，点击Apply Changes按钮，右边的图形将被更新。同理，其他类型的图形都可以实时更新。点击右边的保存，保存此图，命名为search_all_logs_visual。接下来切换到Dashboard页面： 单击新建按钮，选择刚刚保存的search_all_logs_visual图形，面板上将展示该图： 如果有较多数据，我们可以根据业务需求和关注点在Dashboard页面添加多个图表：柱形图，折线图，地图，饼图等等。当然，我们可以设置更新频率，让图表自动更新： 如果设置的时间间隔够短，就很趋近于实时分析了。到这里，ELK平台部署和基本的测试已完成。 参考：http://baidu.blog.51cto.com/71938/1676798http://blog.csdn.net/cnweike/article/details/33736429 来自： http://my.oschina.net/itblog/blog/547250","categories":[{"name":"ELK","slug":"ELK","permalink":"http://lmwtuedu.cn/categories/ELK/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://lmwtuedu.cn/tags/ElasticSearch/"},{"name":"Logstash","slug":"Logstash","permalink":"http://lmwtuedu.cn/tags/Logstash/"},{"name":"Kibana","slug":"Kibana","permalink":"http://lmwtuedu.cn/tags/Kibana/"}],"author":"LJ"},{"title":"SQL如何支持TLS1.2","slug":"2018-07-20-SQL如何支持TLV1.2","date":"2018-07-19T16:00:00.000Z","updated":"2019-09-17T08:18:09.155Z","comments":true,"path":"2018/07/20/2018-07-20-SQL如何支持TLV1.2/","link":"","permalink":"http://lmwtuedu.cn/2018/07/20/2018-07-20-SQL如何支持TLV1.2/","excerpt":"","text":"SQL如何支持TLS1.2近期工作需要送检项目被扫描处以下漏洞： 注意： solution给出的方案是update；当时我看到这个句话时，我内心时崩溃的以及一脸的问好❓❓ 更新，更新What？ 丢给公司的技术支持先查询了（因为我是第一次遇见此问题，手头还有其他项目要忙）； 其他项目忙完已经是两个星期之后，刚忙完手头其他项目（公司对此项目比较重视）； 领导领导的上级来了，来了一顿逼叨逼叨的，说了一大堆； 唉，呀， 我是那种不干活的人吗？ 来了一句“你处理问题能力有问题？” “WTF？？？” 怀疑我的能力，默默的收拾一下，来吧，搞定此bug漏洞所在！有点扯远了，来吧，言归正传！ 环境： Windows7（64位系统 4G内存） SQL2005 我司送检软件 查询了一下： 此漏洞是啥？ 此漏洞对OpenSSL协议有问题？ SSL3？ 那我软件协议是啥版本？ 能支持啥版本呢？ 排查对象还有 针对 CBC模式的呢？？？ 我得搞清楚用了哪些东西（协议以及算法） 链接🔗常见的几种SSL/TLS漏洞及攻击方式 Google以及百度，查询到有这样的一个软件： 对对对，专门针对IIS的一款非常棒棒哒的神器；可以很直观的设置协议看见木有： protocols： 协议； ciphers : 密码（算法）； hash：哈希； KeyExchange：密钥交换； 我们需要设置如下： CipherSuites的选择是根据什么来决定的呢？ 是根据系统的加密套件决定的；加密套件哪里寻找呢？ windows 系统下有一个命令： gpedit.msc SSL的组件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374确定安全套接字层(SSL)使用的密码套件。如果启用此设置，则 SSL 密码套件将按指定的顺序进行排列。如果禁用或不配置此设置，则将使用出厂默认密码套件顺序。SSL2、SSL3、TLS 1.0 和 TLS 1.1 密码套件:TLS_RSA_WITH_AES_128_CBC_SHATLS_RSA_WITH_AES_256_CBC_SHATLS_RSA_WITH_RC4_128_SHATLS_RSA_WITH_3DES_EDE_CBC_SHATLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P256TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P384TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P521TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P256TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P384TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P521TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA_P256TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA_P384TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA_P521TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA_P256TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA_P384TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA_P521TLS_DHE_DSS_WITH_AES_128_CBC_SHATLS_DHE_DSS_WITH_AES_256_CBC_SHATLS_DHE_DSS_WITH_3DES_EDE_CBC_SHATLS_RSA_WITH_RC4_128_MD5SSL_CK_RC4_128_WITH_MD5SSL_CK_DES_192_EDE3_CBC_WITH_MD5TLS_RSA_WITH_NULL_SHATLS_RSA_WITH_NULL_MD5TLS 1.2 SHA256 和 SHA384 密码套件:TLS_RSA_WITH_AES_128_CBC_SHA256TLS_RSA_WITH_AES_256_CBC_SHA256TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P384TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P521TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P521TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P256TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P384TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P521TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384_P384TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384_P521TLS_DHE_DSS_WITH_AES_128_CBC_SHA256TLS_DHE_DSS_WITH_AES_256_CBC_SHA256TLS_RSA_WITH_NULL_SHA256TLS 1.2 ECC GCM 密码套件:TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P256TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P384TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P521TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P384TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P521如何修改此设置:1. 打开一个空白写字板文档。2. 复制可用套件的列表并将其粘贴到该文档中。3. 按正确顺序排列套件；删除不想使用的所有套件。4. 在每个套件名称的末尾键入一个逗号(最后一个套件名称除外)。确保没有嵌入空格。5. 删除所有换行符，以便密码套件名称位于单独的一个长行上。6. 将密码套件行复制到剪贴板，然后将其粘贴到编辑框中。最大长度为 1023 个字符。 为了防止被一些扫描软件扫描出一些什么 TLV POOOLED的这种漏洞；所以我建议你配置TLS1.2 ECC GCM 密码套件； 与之使用的软件也要支持才行，否者OpenSSL进行会话密钥协商的时候，会出错！ SQL2016的数据连接的时候，采用OpenSSL的连接，其实说白了就是走的是HTTPS；如果你不信，可以点击打开浏览器查看百度的协议是啥： 所以我们配置TLS1.2的时候只配置 GCM的密码套件： 1234567TLS 1.2 ECC GCM 密码套件:TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P256TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P384TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P521TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P384TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P521 这样在漏洞扫描的时候，是绝对不会出现 TLS POOLED的漏洞的！ 那其他的漏洞原理是如何设置还有修复的呢？？ 网上查阅过一记录： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238# Copyright 2016, Alexander Hass# http://www.hass.de/content/setup-your-iis-ssl-perfect-forward-secrecy-and-tls-12## Version 1.7# - Windows Version compare failed. Get-CimInstance requires Windows 2012 or later.# Version 1.6# - OS version detection for cipher suites order.# Version 1.5# - Enabled ECDH and more secure hash functions and reorderd cipher list.# - Added Client setting for all ciphers.# Version 1.4# - RC4 has been disabled.# Version 1.3# - MD5 has been disabled.# Version 1.2# - Re-factored code style and output# Version 1.1# - SSLv3 has been disabled. (Poodle attack protection) Write-Host &apos;Configuring IIS with SSL/TLS Deployment Best Practices...&apos;Write-Host &apos;--------------------------------------------------------------------------------&apos; # Disable Multi-Protocol Unified HelloNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\Multi-Protocol Unified Hello\\Server&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\Multi-Protocol Unified Hello\\Server&apos; -name Enabled -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\Multi-Protocol Unified Hello\\Server&apos; -name &apos;DisabledByDefault&apos; -value 1 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\Multi-Protocol Unified Hello\\Client&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\Multi-Protocol Unified Hello\\Client&apos; -name Enabled -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\Multi-Protocol Unified Hello\\Client&apos; -name &apos;DisabledByDefault&apos; -value 1 -PropertyType &apos;DWord&apos; -Force | Out-NullWrite-Host &apos;Multi-Protocol Unified Hello has been disabled.&apos; # Disable PCT 1.0New-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\PCT 1.0\\Server&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\PCT 1.0\\Server&apos; -name Enabled -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\PCT 1.0\\Server&apos; -name &apos;DisabledByDefault&apos; -value 1 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\PCT 1.0\\Client&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\PCT 1.0\\Client&apos; -name Enabled -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\PCT 1.0\\Client&apos; -name &apos;DisabledByDefault&apos; -value 1 -PropertyType &apos;DWord&apos; -Force | Out-NullWrite-Host &apos;PCT 1.0 has been disabled.&apos; # Disable SSL 2.0 (PCI Compliance)New-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 2.0\\Server&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 2.0\\Server&apos; -name Enabled -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 2.0\\Server&apos; -name &apos;DisabledByDefault&apos; -value 1 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 2.0\\Client&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 2.0\\Client&apos; -name Enabled -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 2.0\\Client&apos; -name &apos;DisabledByDefault&apos; -value 1 -PropertyType &apos;DWord&apos; -Force | Out-NullWrite-Host &apos;SSL 2.0 has been disabled.&apos; # NOTE: If you disable SSL 3.0 the you may lock out some people still using# Windows XP with IE6/7. Without SSL 3.0 enabled, there is no protocol available# for these people to fall back. Safer shopping certifications may require that# you disable SSLv3.## Disable SSL 3.0 (PCI Compliance) and enable &quot;Poodle&quot; protectionNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 3.0\\Server&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 3.0\\Server&apos; -name Enabled -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 3.0\\Server&apos; -name &apos;DisabledByDefault&apos; -value 1 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 3.0\\Client&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 3.0\\Client&apos; -name Enabled -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\SSL 3.0\\Client&apos; -name &apos;DisabledByDefault&apos; -value 1 -PropertyType &apos;DWord&apos; -Force | Out-NullWrite-Host &apos;SSL 3.0 has been disabled.&apos; # Add and Enable TLS 1.0 for client and server SCHANNEL communicationsNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.0\\Server&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.0\\Server&apos; -name &apos;Enabled&apos; -value &apos;0xffffffff&apos; -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.0\\Server&apos; -name &apos;DisabledByDefault&apos; -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.0\\Client&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.0\\Client&apos; -name &apos;Enabled&apos; -value &apos;0xffffffff&apos; -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.0\\Client&apos; -name &apos;DisabledByDefault&apos; -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullWrite-Host &apos;TLS 1.0 has been enabled.&apos; # Add and Enable TLS 1.1 for client and server SCHANNEL communicationsNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.1\\Server&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.1\\Server&apos; -name &apos;Enabled&apos; -value &apos;0xffffffff&apos; -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.1\\Server&apos; -name &apos;DisabledByDefault&apos; -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.1\\Client&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.1\\Client&apos; -name &apos;Enabled&apos; -value &apos;0xffffffff&apos; -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.1\\Client&apos; -name &apos;DisabledByDefault&apos; -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullWrite-Host &apos;TLS 1.1 has been enabled.&apos; # Add and Enable TLS 1.2 for client and server SCHANNEL communicationsNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2\\Server&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2\\Server&apos; -name &apos;Enabled&apos; -value &apos;0xffffffff&apos; -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2\\Server&apos; -name &apos;DisabledByDefault&apos; -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2\\Client&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2\\Client&apos; -name &apos;Enabled&apos; -value &apos;0xffffffff&apos; -PropertyType &apos;DWord&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols\\TLS 1.2\\Client&apos; -name &apos;DisabledByDefault&apos; -value 0 -PropertyType &apos;DWord&apos; -Force | Out-NullWrite-Host &apos;TLS 1.2 has been enabled.&apos; # Re-create the ciphers key.New-Item &apos;HKLM:SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Ciphers&apos; -Force | Out-Null # Disable insecure/weak ciphers.$insecureCiphers = @( &apos;DES 56/56&apos;, &apos;NULL&apos;, &apos;RC2 128/128&apos;, &apos;RC2 40/128&apos;, &apos;RC2 56/128&apos;, &apos;RC4 40/128&apos;, &apos;RC4 56/128&apos;, &apos;RC4 64/128&apos;, &apos;RC4 128/128&apos;)Foreach ($insecureCipher in $insecureCiphers) &#123; $key = (Get-Item HKLM:\\).OpenSubKey(&apos;SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Ciphers&apos;, $true).CreateSubKey($insecureCipher) $key.SetValue(&apos;Enabled&apos;, 0, &apos;DWord&apos;) $key.close() Write-Host &quot;Weak cipher $insecureCipher has been disabled.&quot;&#125; # Enable new secure ciphers.# - RC4: It is recommended to disable RC4, but you may lock out WinXP/IE8 if you enforce this. This is a requirement for FIPS 140-2.# - 3DES: It is recommended to disable these in near future. This is the last cipher supported by Windows XP.# - Windows Vista and before &apos;Triple DES 168&apos; was named &apos;Triple DES 168/168&apos; per https://support.microsoft.com/en-us/kb/245030$secureCiphers = @( &apos;AES 128/128&apos;, &apos;AES 256/256&apos;, &apos;Triple DES 168&apos;)Foreach ($secureCipher in $secureCiphers) &#123; $key = (Get-Item HKLM:\\).OpenSubKey(&apos;SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Ciphers&apos;, $true).CreateSubKey($secureCipher) New-ItemProperty -path &quot;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Ciphers\\$secureCipher&quot; -name &apos;Enabled&apos; -value &apos;0xffffffff&apos; -PropertyType &apos;DWord&apos; -Force | Out-Null $key.close() Write-Host &quot;Strong cipher $secureCipher has been enabled.&quot;&#125; # Set hashes configuration.New-Item &apos;HKLM:SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Hashes&apos; -Force | Out-NullNew-Item &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Hashes\\MD5&apos; -Force | Out-NullNew-ItemProperty -path &apos;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Hashes\\MD5&apos; -name Enabled -value 0 -PropertyType &apos;DWord&apos; -Force | Out-Null $secureHashes = @( &apos;SHA&apos;, &apos;SHA256&apos;, &apos;SHA384&apos;, &apos;SHA512&apos;)Foreach ($secureHash in $secureHashes) &#123; $key = (Get-Item HKLM:\\).OpenSubKey(&apos;SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Hashes&apos;, $true).CreateSubKey($secureHash) New-ItemProperty -path &quot;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Hashes\\$secureHash&quot; -name &apos;Enabled&apos; -value &apos;0xffffffff&apos; -PropertyType &apos;DWord&apos; -Force | Out-Null $key.close() Write-Host &quot;Hash $secureHash has been enabled.&quot;&#125; # Set KeyExchangeAlgorithms configuration.New-Item &apos;HKLM:SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\KeyExchangeAlgorithms&apos; -Force | Out-Null$secureKeyExchangeAlgorithms = @( &apos;Diffie-Hellman&apos;, &apos;ECDH&apos;, &apos;PKCS&apos;)Foreach ($secureKeyExchangeAlgorithm in $secureKeyExchangeAlgorithms) &#123; $key = (Get-Item HKLM:\\).OpenSubKey(&apos;SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\KeyExchangeAlgorithms&apos;, $true).CreateSubKey($secureKeyExchangeAlgorithm) New-ItemProperty -path &quot;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\KeyExchangeAlgorithms\\$secureKeyExchangeAlgorithm&quot; -name &apos;Enabled&apos; -value &apos;0xffffffff&apos; -PropertyType &apos;DWord&apos; -Force | Out-Null $key.close() Write-Host &quot;KeyExchangeAlgorithm $secureKeyExchangeAlgorithm has been enabled.&quot;&#125; # Set cipher suites order as secure as possible (Enables Perfect Forward Secrecy).$os = Get-WmiObject -class Win32_OperatingSystemif ([System.Version]$os.Version -lt [System.Version]&apos;10.0&apos;) &#123; Write-Host &apos;Use cipher suites order for Windows 2008R2/2012/2012R2.&apos; $cipherSuitesOrder = @( &apos;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P521&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P521&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P384&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P521&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P384&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA_P256&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P521&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P384&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_P256&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P521&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P384&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P521&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P384&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256_P256&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384_P521&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384_P384&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P521&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P384&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256_P256&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA_P521&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA_P384&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA_P256&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA_P521&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA_P384&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA_P256&apos;, &apos;TLS_RSA_WITH_AES_256_GCM_SHA384&apos;, &apos;TLS_RSA_WITH_AES_128_GCM_SHA256&apos;, &apos;TLS_RSA_WITH_AES_256_CBC_SHA256&apos;, &apos;TLS_RSA_WITH_AES_128_CBC_SHA256&apos;, &apos;TLS_RSA_WITH_AES_256_CBC_SHA&apos;, &apos;TLS_RSA_WITH_AES_128_CBC_SHA&apos;, &apos;TLS_RSA_WITH_3DES_EDE_CBC_SHA&apos; )&#125;else &#123; Write-Host &apos;Use cipher suites order for Windows 10/2016 and later.&apos; $cipherSuitesOrder = @( &apos;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA&apos;, &apos;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA&apos;, &apos;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA&apos;, &apos;TLS_RSA_WITH_AES_256_GCM_SHA384&apos;, &apos;TLS_RSA_WITH_AES_128_GCM_SHA256&apos;, &apos;TLS_RSA_WITH_AES_256_CBC_SHA256&apos;, &apos;TLS_RSA_WITH_AES_128_CBC_SHA256&apos;, &apos;TLS_RSA_WITH_AES_256_CBC_SHA&apos;, &apos;TLS_RSA_WITH_AES_128_CBC_SHA&apos;, &apos;TLS_RSA_WITH_3DES_EDE_CBC_SHA&apos; )&#125;$cipherSuitesAsString = [string]::join(&apos;,&apos;, $cipherSuitesOrder)# One user reported this key does not exists on Windows 2012R2. Cannot repro myself on a brand new Windows 2012R2 core machine. Adding this just to be save.New-Item &apos;HKLM:\\SOFTWARE\\Policies\\Microsoft\\Cryptography\\Configuration\\SSL\\00010002&apos; -ErrorAction SilentlyContinueNew-ItemProperty -path &apos;HKLM:\\SOFTWARE\\Policies\\Microsoft\\Cryptography\\Configuration\\SSL\\00010002&apos; -name &apos;Functions&apos; -value $cipherSuitesAsString -PropertyType &apos;String&apos; -Force | Out-Null Write-Host &apos;--------------------------------------------------------------------------------&apos;Write-Host &apos;NOTE: After the system has been rebooted you can verify your server&apos;Write-Host &apos; configuration at https://www.ssllabs.com/ssltest/&apos;Write-Host &quot;--------------------------------------------------------------------------------`n&quot; Write-Host -ForegroundColor Red &apos;A computer restart is required to apply settings. Restart computer now?&apos;Restart-Computer -Force -Confirm 注意提示： 有些cipherSuitesOrder已经是弱的，或者已经是漏洞的算法；注意上面提到的一些内容，只是作为参考其深入原理。 我在操作的过程中查阅到了一些问题： 因为我发现我设置通信协议为 TLS1.2 之后 SQL的客户端连接访问木有问题； 但是我的程序跑不起来了；坑爹了，到底哪里有问题了；就查阅到可能不支持TLS1.2；就是上述的截图；地址🔗http://kenhamady.com/cru/archives/2867 原来它娘的不支持TLS1.2 走的是TLS1.0； 哎呀，有点坑爹呀，木办法，继续得查询资料Google到这样子的一份资料： 需要安装新的驱动程序，然后才能通过新的语法去连接SQL高版本支持的TLS1.2； 驱动连接的下载地址：https://docs.microsoft.com/en-us/sql/connect/oledb/oledb-driver-for-sql-server?view=sql-server-2017#3-microsoft-ole-db-driver-for-sql-server-msoledbsql 有点特别强调： SQL2005版本是无法支持TLS1.2的；所以它是有TLS1.0的漏洞 TLS POOLED的； 希望我写的东西，能帮到一些童鞋理解一些里面的东西～～～～ 说白了很简单： 下载SQL20016的数据库，好好安装；完成之后下载客户端2017或者其他支持TLS1.2的都行，最好是最新版本，为什么捏？因为新的东西支持的算法以及协议会比较完善；不会太多漏洞；但是也是有风险的，例如一些语法可能不支持了，需要修改你程序的一些代码才能兼容和运行起来； 然后下载新的连接驱动；那么，就基本OK了。","categories":[{"name":"SQL","slug":"SQL","permalink":"http://lmwtuedu.cn/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://lmwtuedu.cn/tags/SQL/"},{"name":"TLV1.2","slug":"TLV1-2","permalink":"http://lmwtuedu.cn/tags/TLV1-2/"}],"author":"LJ"},{"title":"SQL2005 配置SSL证书流程","slug":"2018-06-14-SQL2005 配置SSL证书流程","date":"2018-06-13T16:00:00.000Z","updated":"2019-09-17T08:17:51.041Z","comments":true,"path":"2018/06/14/2018-06-14-SQL2005 配置SSL证书流程/","link":"","permalink":"http://lmwtuedu.cn/2018/06/14/2018-06-14-SQL2005 配置SSL证书流程/","excerpt":"","text":"SQL2005 配置SSL证书流程背景 本人负责公司项目，送检公安部的时候，SQL2005的数据库被检测出如下问题，需要修复证书制作问题，查阅问题，特整理出来供大家参考。 说明： 安装的SQL2005的数据库，自带动生成的证书是RSA1024和SHA-1的算法；SHA-1的算法已经被视为弱哈希算法（2017一月份）。所以我们得自己制作一张RSA1024以上的SHA256以上的证书，而且要是服务器的证书； 制作流程检测环境： windows7 64位系统； 制作环境： windows7 64位系统； 启动系统的ISS 说明： 安装SQL2005数据库的时候，如果报的任何错误和警告⚠️都需要认真查看和解决！ SQL2005数据库安装提前启动ISS服务，我本人操作时，先开启windos功能； web管理器的里面全部开启，万维网的也全部开启； （先不管有木有用，反正你也不清楚安装过程那些需要哪些不需要，先全部开放，后续如果不需要再关闭）； 有人可能会问，为什么不先安装后续解决开启； 呃，因为安装过程中软件会建立一些联系关系呀，例如路径之类的，注册表之类的，没有开启，它如何寻找到哪里呢？ 所以本人不建议你先安装而不去开启这些服务（这都是本人踩过很多坑总结的）；还有一点就是SQL的卸载很麻烦；所以争取一次搞定，不出现任何问题。前人已经帮你栽树，你只需乘凉就好啦！ SQL安装 具体安装流程我就不细说了，注意我截图的内容，强调二个位置（公司技术支持竟然不知道区别，得拉出去打屁屁）； SQL Server Management Studio 是客户端的登陆界面； SQL Server Configuration Management才是SQL的服务设置界面 制作证书 前提安装VS2010的环境，因为只有VS2010的才支持SHA256之后的哈希算法；VS2008只支持MD5和SHA1（我司编译器，哎呀，讨厌死微软一套了） 如果你们的公司有证书服务器的话，可以略过此步骤啦，没有得继续查看哟 安装证书 证书安装到ISS服务 自己制作的证书只适合测试用，不受CA信赖，所以需要注册到根证书池；双击安装到证书池 SQL2005注册表查看替换SQL默认证书 Certificate 的存储的事证书的指纹哈希值；即IIS服务器证书的指纹哈希值 安装之后重新启动SQL的服务器程序；通过配置查看证书是否成功 如果报错，或者启动不了，说明CN的制作的名称与SQL的ServerName的名称不一样，最好的方式事查看 SQL的日志 ERRORLOG的文件，里面有一行数据会显示server name的名称；我们需要记录，用于制作证书作为 CN的名称； 也可查看注册表 重新链接SQL2005 注意服务器启动项 如果你是普通用户，请以管理员的身份运行程序（我司技术支持不知道如何用管理员身份运行，打屁屁）； 右键点击运行程序，选择管理员运行； OK，SQL2005 的SSL配置完成 用户可以明文链接 用户可以用SSL证书链接 用户可以用window程序登陆链接 参考资料 不分先后顺序，对我解决我自己的问题，提供很大帮助和思路 【资料参考】：https://blogs.msdn.microsoft.com/apgcdsd/2011/03/21/sql-server-1-sql-server-connection-encyption/ 【内容截图显示】： [参考资料]SQL制作证书流程：https://blogs.msdn.microsoft.com/apgcdsd/2011/01/19/how-tosql-server/ 【参考资料】https://docs.microsoft.com/zh-cn/sql/tools/configuration-manager/protocols-for-mssqlserver-properties-flags-tab?view=sql-server-2017 【内容截图】证书内容截图： 如何查找证书【参考资料】https://support.microsoft.com/en-us/help/318605/how-sql-server-uses-a-certificate-when-the-force-protocol-encryption-o bug漏洞：5号： SSLv3 Padding Oracle On Downgraded Legacy Encryption Vulnerability(POOLE)6号： TLS Padding Oracle Information Disclosure Vulnerability(TLS POODLE)【参考资料】https://blog.csdn.net/u011078940/article/details/51554210 修改修改SQL的注册键值【参考资料】http://stackoverflow.org.cn/front/ask/view?ask_id=660021 还有一点要注意的是：CN的名称； 如果CN的名称和主机不一样注意修改： 证书从哪里来？制作证书的流程：【资料参考】【网站】https://blogs.msdn.microsoft.com/apgcdsd/2011/01/19/how-tosql-server/ 注意:selfssl.exe 制作的证书默认的哈希算法是SHA-1； 不能修改，而SHA-1已经在2017年已经被判定为不安全哈希算法；因此不能制作RSA2048SHA256的证书。只能通过makeCert的方式进行制作。 而通过makecert制作的时候，makecert的版本也要注意，VS2008版本只能制作MD5和SHA1的；VS2010的版本才可以制作SHA256以上的版本；【参考资料】https://msdn.microsoft.com/zh-cn/library/bfsktky3(v=vs.100).aspx 注意此版本信息查阅： 证书制作好了之后，就是安装证书： 链接地址参考： http://stackoverflow.org.cn/front/ask/view?ask_id=660021 https://blog.csdn.net/u011078940/article/details/51554210 https://blogs.msdn.microsoft.com/apgcdsd/2011/01/19/how-tosql-server/ https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-1.1/bfsktky3(v=vs.71) https://www.microsoft.com/en-us/download/confirmation.aspx?id=17275 https://docs.microsoft.com/zh-cn/sql/tools/configuration-manager/protocols-for-mssqlserver-properties-flags-tab?view=sql-server-2017 https://blogs.msdn.microsoft.com/apgcdsd/2011/03/21/sql-server-1-sql-server-connection-encyption/ https://support.microsoft.com/en-us/help/316898/how-to-enable-ssl-encryption-for-an-instance-of-sql-server-by-using-mi https://social.technet.microsoft.com/Forums/ie/en-US/f9dfdf68-df16-45c6-a349-72b3129f97fc/how-to-generate-a-csr-in-iis-75-with-sha2-algorithm?forum=winserversecurity https://blog.csdn.net/wuwo333/article/details/53020403 https://www.cnblogs.com/daxueba-ITdaren/p/4635784.html https://technet.microsoft.com/en-us/library/dd632629.aspx https://stackoverflow.com/questions/36817627/ssl-certificate-missing-from-dropdown-in-sql-server-configuration-manager https://msdn.microsoft.com/zh-sg/library/bfsktky3(v=vs.100) https://msdn.microsoft.com/zh-sg/library/bfsktky3(v=vs.100)","categories":[{"name":"SQL","slug":"SQL","permalink":"http://lmwtuedu.cn/categories/SQL/"}],"tags":[{"name":"SQL2005","slug":"SQL2005","permalink":"http://lmwtuedu.cn/tags/SQL2005/"},{"name":"SSL","slug":"SSL","permalink":"http://lmwtuedu.cn/tags/SSL/"}],"author":"LJ"},{"title":"前后端API交互如何保证数据安全性","slug":"2018-06-08-前后端API交互如何保证数据安全性？","date":"2018-06-07T16:00:00.000Z","updated":"2019-09-17T08:17:26.362Z","comments":true,"path":"2018/06/08/2018-06-08-前后端API交互如何保证数据安全性？/","link":"","permalink":"http://lmwtuedu.cn/2018/06/08/2018-06-08-前后端API交互如何保证数据安全性？/","excerpt":"","text":"前后端API交互如何保证数据安全性？前言前后端分离的开发方式，我们以接口为标准来进行推动，定义好接口，各自开发自己的功能，最后进行联调整合。无论是开发原生的APP还是webapp还是PC端的软件,只要是前后端分离的模式，就避免不了调用后端提供的接口来进行业务交互。 网页或者app，只要抓下包就可以清楚的知道这个请求获取到的数据，这样的接口对爬虫工程师来说是一种福音，要抓你的数据简直轻而易举。 数据的安全性非常重要，特别是用户相关的信息，稍有不慎就会被不法分子盗用，所以我们对这块要非常重视，容不得马虎。 如何保证API调用时数据的安全性？ 通信使用https 请求签名，防止参数被篡改 身份确认机制，每次请求都要验证是否合法 APP中使用ssl pinning防止抓包操作 对所有请求和响应都进行加解密操作 等等方案……. 对所有请求和响应都进行加解密操作方案有很多种，当你做的越多，也就意味着安全性更高，今天我跟大家来介绍一下对所有请求和响应都进行加解密操作的方案，即使能抓包，即使能调用我的接口，但是我返回的数据是加密的，只要加密算法够安全，你得到了我的加密内容也对我没什么影响。 像这种工作最好做成统一处理的，你不能让每个开发都去关注这件事情，如果让每个开发去关注这件事情就很麻烦了，返回数据时还得手动调用下加密的方法，接收数据后还得调用下解密的方法。 为此，我基于Spring Boot封装了一个Starter, 内置了AES加密算法。GitHub地址如下： https://github.com/yinjihuan/spring-boot-starter-encrypt 先来看看怎么使用，可以下载源码，然后引入即可，然后在启动类上增加@EnableEncrypt注解开启加解密操作： 1234567@EnableEncrypt@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; SpringApplication.run(App.class, args); &#125;&#125; 增加加密的key配置： 12spring.encrypt.key=abcdef0123456789spring.encrypt.debug=false spring.encrypt.key：加密key，必须是16位 spring.encrypt.debug：是否开启调试模式,默认为false,如果为true则不启用加解密操作 为了考虑通用性，不会对所有请求都执行加解密，基于注解来做控制 响应数据需要加密的话，就在Controller的方法上加@Encrypt注解即可。 12345@Encrypt@GetMapping(&quot;/list&quot;)public Response queryNews(String city) &#123; return Response.ok(city);&#125; 当我们访问/list接口时，返回的数据就是加密之后base64编码的格式。 还有一种操作就是前段提交的数据，分为2种情况，一种是get请求，这种暂时没处理，后面再考虑，目前只处理的post请求，基于json格式提交的方式，也就是说后台需要用@RequestBody接收数据才行, 需要解密的操作我们加上@Decrypt注解即可。 123456@Decrypt@PostMapping(&quot;/save&quot;)public Response savePageLog(@RequestBody PageLogParam logParam, HttpServletRequest request) &#123; pageLogService.save(logParam); return Response.ok();&#125; 加了@Decrypt注解后，前端提交的数据需要按照AES加密算法，进行加密，然后提交到后端，后端这边会自动解密，然后再映射到参数对象中。 上面讲解的都是后端的代码，前端使用的话我们以js来讲解，当然你也能用别的语言来做，如果是原生的安卓app也是用java代码来处理。 前段需要做的就2件事情： 统一处理数据的响应，在渲染到页面之前进行解密操作 当有POST请求的数据发出时，统一加密 js加密文件请参考我GitHub中encrypt中的aes.js,crypto-js.js,pad-zeropadding.js 我们以axios来作为请求数据的框架，用axios的拦截器来统一处理加密解密操作 首先还是要封装一个js加解密的类，需要注意的是加密的key需要和后台的对上，不然无法相互解密，代码如下： 1234567891011121314151617181920212223var key = CryptoJS.enc.Latin1.parse(&apos;abcdef0123456789&apos;);var iv = CryptoJS.enc.Latin1.parse(&apos;abcdef0123456789&apos;);// 加密function EncryptData(data) &#123; var srcs = CryptoJS.enc.Utf8.parse(data); var encrypted = CryptoJS.AES.encrypt(srcs, key, &#123; mode : CryptoJS.mode.ECB, padding : CryptoJS.pad.Pkcs7 &#125;); return encrypted.toString();&#125;// 解密function DecryptData(data) &#123; var stime = new Date().getTime(); var decrypt = CryptoJS.AES.decrypt(data, key, &#123; mode : CryptoJS.mode.ECB, padding : CryptoJS.pad.Pkcs7 &#125;); var result = JSON.parse(CryptoJS.enc.Utf8.stringify(decrypt).toString()); var etime = new Date().getTime(); console.log(&quot;DecryptData Time:&quot; + (etime - stime)); return result;&#125; axios拦截器中统一处理代码： 1234567891011121314151617181920// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 对所有POST请加密，必须是json数据提交，不支持表单 if (config.method == &quot;post&quot;) &#123; config.data = EncryptData(JSON.stringify(config.data)); &#125; return config; &#125;, function (error) &#123; return Promise.reject(error);&#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 后端返回字符串表示需要解密操作 if(typeof(response.data) == &quot;string&quot;)&#123; response.data = DecryptData(response.data); &#125; return response; &#125;, function (error) &#123; return Promise.reject(error);&#125;); 到此为止，我们就为整个前后端交互的通信做了一个加密的操作，只要加密的key不泄露，别人得到你的数据也没用，问题是如何保证key不泄露呢？ 服务端的安全性较高，可以存储在数据库中或者配置文件中，毕竟在我们自己的服务器上，最危险的其实就时前端了，app还好，可以打包，但是要防止反编译等等问题。 如果是webapp则可以依赖于js加密来实现，下面我给大家介绍一种动态获取加密key的方式，只不过实现起来比较复杂，我们不上代码，只讲思路： 加密算法有对称加密和非对称加密，AES是对称加密，RSA是非对称加密。之所以用AES加密数据是因为效率高，RSA运行速度慢,可以用于签名操作。 我们可以用这2种算法互补，来保证安全性，用RSA来加密传输AES的秘钥，用AES来加密数据，两者相互结合，优势互补。 其实大家理解了HTTPS的原理的话对于下面的内容应该是一看就懂的，HTTPS比HTTP慢的原因都是因为需要让客户端与服务器端安全地协商出一个对称加密算法。剩下的就是通信时双方使用这个对称加密算法进行加密解密。 客户端启动，发送请求到服务端，服务端用RSA算法生成一对公钥和私钥，我们简称为pubkey1,prikey1，将公钥pubkey1返回给客户端。 客户端拿到服务端返回的公钥pubkey1后，自己用RSA算法生成一对公钥和私钥，我们简称为pubkey2,prikey2，并将公钥pubkey2通过公钥pubkey1加密，加密之后传输给服务端。 此时服务端收到客户端传输的密文，用私钥prikey1进行解密，因为数据是用公钥pubkey1加密的，通过解密就可以得到客户端生成的公钥pubkey2 然后自己在生成对称加密，也就是我们的AES,其实也就是相对于我们配置中的那个16的长度的加密key,生成了这个key之后我们就用公钥pubkey2进行加密，返回给客户端，因为只有客户端有pubkey2对应的私钥prikey2，只有客户端才能解密，客户端得到数据之后，用prikey2进行解密操作，得到AES的加密key,最后就用加密key进行数据传输的加密，至此整个流程结束。 ##spring-boot-starter-encrypt原理最后我们来简单的介绍下spring-boot-starter-encrypt的原理吧，也让大家能够理解为什么Spring Boot这么方便，只需要简单的配置一下就可以实现很多功能。 启动类上的@EnableEncrypt注解是用来开启功能的,通过@Import导入自动配置类 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;EncryptAutoConfiguration.class&#125;)public @interface EnableEncrypt &#123;&#125; EncryptAutoConfiguration中配置请求和响应的处理类，用的是Spring中的RequestBodyAdvice和ResponseBodyAdvice，在Spring中对请求进行统计处理比较方便。如果还要更底层去封装那就要从servlet那块去处理了。 12345678910111213141516171819202122@Configuration@Component@EnableAutoConfiguration@EnableConfigurationProperties(EncryptProperties.class)public class EncryptAutoConfiguration &#123; /** * 配置请求解密 * @return */ @Bean public EncryptResponseBodyAdvice encryptResponseBodyAdvice() &#123; return new EncryptResponseBodyAdvice(); &#125; /** * 配置请求加密 * @return */ @Bean public EncryptRequestBodyAdvice encryptRequestBodyAdvice() &#123; return new EncryptRequestBodyAdvice(); &#125;&#125; 通过RequestBodyAdvice和ResponseBodyAdvice就可以对请求响应做处理了，大概的原理就是这么多了。","categories":[{"name":"code","slug":"code","permalink":"http://lmwtuedu.cn/categories/code/"}],"tags":[{"name":"safe","slug":"safe","permalink":"http://lmwtuedu.cn/tags/safe/"},{"name":"API","slug":"API","permalink":"http://lmwtuedu.cn/tags/API/"}],"author":"尹吉欢"},{"title":"累死你的不是工作，而是工作方法","slug":"2018-05-18-累死你的不是工作，而是工作方法","date":"2018-05-17T16:00:00.000Z","updated":"2019-09-17T08:16:39.903Z","comments":true,"path":"2018/05/18/2018-05-18-累死你的不是工作，而是工作方法/","link":"","permalink":"http://lmwtuedu.cn/2018/05/18/2018-05-18-累死你的不是工作，而是工作方法/","excerpt":"","text":"累死你的不是工作，而是工作方法我们一直都认为，如果一个人智商情商正常、学习和工作意愿高，就一定能出成绩。 然而，我带过很多人，也招过很多人，却发现一个奇怪的现象：有一些人，十分有意愿学习，非常努力，智商情商也都正常，然而工作产出却非常低，甚至不如很多资质低于他们的人。 我一直百思不得其解，一度怀疑自己看人不准。直到前阵子看到吴军的这段叙述，才幡然醒悟，仔细回想了这些人的工作方式，将他们与产出高的人相比，发现他们无一例外都存在这三个问题： 问题1：只关注任务，不关注目标假如你的老板正在飞机上，还有1小时落地，下来之后需要给客户做一个重要汇报，而你需要给他做一份PPT。但因为你错估了时间，导致PPT草草做完，而且发现其中一些数据没有，你怎么办？ 低效人士的做法是：疯狂地找数据，最后可能数据有了，然而PPT没有来得及做完，或者质量不高。 一般人的做法是：找人帮自己一起找数据。 而最高效的那些人，会根据老板此次汇报的目的，判断这些数据在其中的作用大小，如果作用不大，那么就把时间花在完善重要页数、而不是找数据上，如果很关键，那么就找其他人帮忙，或者找一些替代数据。 这三类人之间的差距，其实就是任务导向与目标导向的差距。 我此前的咨询公司，在做高潜人才研究的时候，有个发现：高潜力的人才是有共性的，具备这些共性的人，几乎做什么都能做好，而不具备的，几乎做任何工作都会障碍重重。 这其中，有一项共性就是Result-driven（结果驱动）。那些高产出的人，未必动作更快，而是更善于判断，什么事情对结果是最有效的，然后，用尽一切办法保证结果达成，而不是死守着原有的工作任务。 实际上，结果驱动不仅仅是一种工作习惯，更是一种思维方式。这种以终为始的思维模式，是我自己刻意训练的最有用的思维模式之一。 比如思维训练营里，有学员问我：如何让自己对一个行业有真知灼见？ 想想看，如果是你，会如何回答？ 我的回答方式，是反问她：具备真知灼见的目的是什么呢？是想让客户更加信任你、还是想让老板看到你的进步？ 假设你是希望客户信任你，觉得你懂他，那你要做的，就是看这个行业里的客户有什么痛点，然后针对这几个痛点，下功夫研究和分析，有更多洞见，然后借机沟通出去。了解一个行业，是一个太大的话题，没有目标，根本无从下手。 所以，没有结果驱动的思维，而仅仅死守着工作任务，最终就是，出工不出活儿。 问题2：应激式工作，而非统筹式工作如果你观察周围的同事，会发现，整天风风火火、急得上蹿下跳、各种任务来回切换的人，有时候产出并不高。看他们工作，就好像打地鼠一样，打完一个，另一个又冒上来，连看的人都跟着焦虑起来。 而另一类人，他们做事专注、条理清晰、看起来很淡定，但最后，多困难的事儿都默默搞定了。 两者的差别就在于，第一类人总是应激式工作。他们每天起来的第一件事，不是规划当天的工作，而是马上投入工作，以至于到了下班之后，发现还有很多事情没做完，而没做完的，可能又是最重要的。 另外，领导临时给个任务、客户临时有个要求、同事临时要个数据，他们都会停下手里的事情，去忙这些，最终，在任务的切换上花费了巨大的精力。 我跟公司的运营打过一个比方：假设你每项工作任务平均半小时可以做完，而任务之间的切换通常也要半小时，如果你经常一项不做完就切换到下一项，就算每个任务中途切换一次吧，那就意味着，8小时的工作时间，你至少有4小时都花在任务切换上了。 这种应激式工作方式无疑是低效的，那什么才是高效的呢？统筹式工作。 真正的统筹式工作，有几个特征： 特征一，有计划地工作 我通常周日晚上就会排好下周每天的工作，而每天早上会排好当天的工作。而且，任务清单在工作的时候一直开着、实时更新，完成一项删掉一项，临时增加一项就插入相应的时间段，当天完不成的、非紧急的任务，我就改成第二天的日期。 这种方式，会让自己很有掌控感，多少事情来了，都不会乱了阵脚。 当然，在做计划的时候，你需要为高价值问题分配最多专门的时间。我此前特地写过一篇文章，就提到，大部分人在80%的时间里都是做无用功，根本原因就是没搞清楚真正要解决的问题。这6个问题，可以帮你省80%的无用功。 特征二，形成自己固定的时间习惯 比如我的习惯是，在上午做需要烧脑的事情、在交通工具上听书、在饭后效率不高的时候集中回复微信消息和留言、在等人的时候构思下篇文章主题、在疲劳的时候刷一下公众号、在傍晚的时候跟团队开会、在晚上做一个简单总结。 这种习惯，一方面把不同难度的工作跟自己的效率波峰波谷相匹配，达到效率最大化；另一方面，我会清楚地知道，5分钟、10分钟、30分钟，对我来说分别可以干什么，这样就不会一有碎片时间，就习惯性地刷朋友圈了。 特征三，及时记录、每天总结 当你正在工作的时候，老板布置了一个任务、客户又来了一个问题，你会如何呢？很多人就直接扑到临时任务上去了，但真正好的做法是，如果不是十万火急，你可以快速用关键词记在笔记本上，不需要任何思考，然后马上回到刚才的任务，做完再看笔记本。 另外，你在一天当中，学到了什么、犯了什么错误，当时也要记下来，因为过了那个时候，你很快就会忘，然后继续犯这个错误。当然，这些记录，晚上都需要进行整理。 我曾说过，此前8年多的顾问生涯里，成长最快的那半年，我每天都坚持写工作日记。 另外，记录还有一个好处，就是可以减轻大脑负担。每天的例行工作、自己常犯的错误，这些都可以列清单。你的大脑是用来思考的，是很宝贵的，别把一支笔就可以做的事情，强加给你的大脑来做。 问题3：几乎从不“偷懒”“懒癌”是第一生产力。仔细盘点一下，我们哪样创新不是因为懒呢？不想走路，有了汽车；不想爬楼，有了电梯；不想打扫，有了扫地机器人…… 工作中的大部分事情，并不是一次性的，而是持续的，那么就可以在第一次做的时候，搭好框架。 比如，我让运营每周做一次数据分析，这个事情是重复性的，所以高效的做法是：建一张excel表格，把固定需要分析的参数都做好公式，每周只需要把导出来的源数据贴进去，刷新之后参数就出来，然后只需要看参数来得出结论。 当然，这里所说的偷懒，不仅是善用工具，还包括善用他人。 比如，你从来没做过数据分析，那么就先去找找前人怎么做的；比如，你有自己的团队或者实习生，那就不要做任何他们就可以做的事情；再比如，去运营社群，摸索出一套群主激励机制，比你自己去做群主，要高效得多。 所以，这三个让你Work Smart的工作方式，听起来难吗？一点也不，而且你很可能也听说过。但是，为什么很多人做不到呢？我观察下来，有几个障碍： 障碍1：工作环境所限。 很多人的工作性质，就不是结果导向型的，而是任务导向型的。他的工作岗位要求他做的，就是完成任务，至于背后的出发点，不需要知道。而且，领导有可能就是考核努力、考核苦劳，而不是考核产出。 实际上，工作性质对一个人的思维方式、行为习惯的影响，大到超乎想象。 你去看，刚毕业的时候，一个学校一个专业的同学，看起来差不多，但过了几年，你会发现，只要接触一个人几分钟，听他说几句话，就能大致判断出他的职业。 再极端一些的，多年前我曾经因为要帮客户设计流程，去他们的产线观察生产过程，在噪音极大、灯光昏暗的厂房里，我看着流水线工人机械地盯着机器、等待换箱，几个小时下来，我自己也开始反应迟钝、敏锐度下降了。 障碍2：没有资深的人辅导。 从开头的案例可以看出，Google工程师那么优秀的一群人，在从校园进入公司之后，也需要有经验的人辅导。 但很多公司并不像Google那样，重视对新人工作方式的培养，将Work Smart提到非常高的位置。 他们往往只重视教员工What（需要做哪些事情、用什么工具等等），却没有How（如何聪明地做这些事情）和Why（这些事情对公司、对客户有什么帮助、要达到何种目的），导致员工的聪明才干发挥不出来，没有成就感。 障碍3：思维方式固化。 一部分人，会在工作多年之后，发现工作性质和工作环境的负面影响，醒悟过来想要改变。 然而，从学校踏入社会的这几年，是思维和工作方式形成的关键几年，如果任务导向、应激式努力、闷头蛮干的工作方式在大脑中固化了，形成了下意识思维，是很难扭转过来的。 我带过几个人，此前的工作经历都是任务式、应激式的，在跟他们合作的时候，的确能够感受到他们与自己固有思维作斗争的痛苦与挣扎，然而，并不是每个人最终都能挣扎出来、突破自我的。 所以，年轻时候的工作选择，你选择的不只是一份工作，而是一种思维习惯、工作方式、价值观甚至生活方式。 在初入职场的几年，处于何种工作环境、跟谁一起工作、被谁辅导工作，足以影响你的下半辈子。","categories":[{"name":"article","slug":"article","permalink":"http://lmwtuedu.cn/categories/article/"}],"tags":[{"name":"news","slug":"news","permalink":"http://lmwtuedu.cn/tags/news/"}],"author":"搜狐网"},{"title":"今日头条》再被整肃　“内涵段子”永久关停","slug":"2018-04-12-今日头条—内涵段子","date":"2018-04-11T16:00:00.000Z","updated":"2019-09-17T08:16:34.553Z","comments":true,"path":"2018/04/12/2018-04-12-今日头条—内涵段子/","link":"","permalink":"http://lmwtuedu.cn/2018/04/12/2018-04-12-今日头条—内涵段子/","excerpt":"","text":"##《今日头条》再被整肃 “内涵段子”永久关停 再诚恳的道歉也改变不了命运 佛曰：再诚恳的道歉也改变不了命运 今日头条创始人、CEO 张一鸣的致歉信成为今日热点，张老板的道歉信写得极其诚恳，完全不像一个工程师的手笔，严重怀疑是某知名写手的代笔。他在致歉信中说：‌‌“我真诚地向监管部门致歉，向用户及同事们道歉。从昨天下午接到监管部门的通知到现在，我一直处在自责和内疚之中，一夜未眠。产品走错了路，出现了与社会主义核心价值观不符的内容，没有贯彻好舆论导向，接受处罚，所有责任在我。我们片面注重增长和规模，却没有及时强化质量和责任，忽视了引导用户获取正能量信息的责任。对承担企业社会责任，弘扬正能量，把握正确的舆论导向认识不够，思想上缺乏重视。一直以来，我们过分强调技术的作用，却没有意识到，技术必须要用社会主义核心价值观来引导，传播正能量，符合时代要求，尊重公序良俗。‌‌”他还声称今日头条将永久关停‌‌“内涵段子‌‌”客户端软件及公众号，还说要强化总编辑责任制，全面纠正算法和机器审核的缺陷，不断强化人工运营和审核，将现有6000人的运营审核队伍，扩大到10000 人。 作为一个成功的知名互联网企业的老总，张老板的道歉信已经到了声泪俱下诚惶诚恐卑躬屈膝的程度，让人几乎不忍卒读心生同情了。建议研究企业史的朋友好好保存这份致歉信，它是了解当下营商环境和企业家生存法则的经典文献，其史料价值也许不亚于四十年前小岗村农民要求包产到户的血手印文书。据说改革开放都四十年了，此国做企业的还动辄得罪，动不动就要写检讨过关，也难怪境外势力血口喷人说咱们搞的不是市场经济了。至于咱这里搞的是啥子经济，经济学家们有各种忽悠，看了张老板今天的检讨，我突然恍然大悟：原来我们搞的是检讨经济。 在朋友圈，看到张鸣老师调侃道：‌‌“原来以为张一鸣比我多个‌‌‘一’，牛逼大了。现在看来，他还不如我，我只是在小时候写检讨，他都这个岁数了，还在写检讨。‌‌”确实，张一鸣同志比起有点反骨的知识人，这个检讨够低声下气的，可是那么大的企业摆在人家手心里，不服软还真不行，张鸣老师是一人吃饱全家不饿，张一鸣同志却是身家性命全靠D恩，我辈本是蓬蒿人，岂能摧眉折腰事权贵？不得不感叹，在赵家 村当老板，真是窝囊憋屈得很，想站着把钱挣，实在很难，想学《白鹿原》中的白嘉轩那样挺直腰杆，可是任凭你多么有经营才华，一不小心就有绑匪的铁棒抽来，直接把你干趴下！ 去年春节跟我90后的侄儿聊天，得知他在某直播公司做经纪，我说：那你得小心，你这个行业是打擦边球的，很可能因为低俗就被端掉。侄儿确信心满满的说：我们不谈政治，我支持某大大，不会有事的。我说：不是你不谈政治政治就不关心你，互联网头上一直悬着把剑，你知道网信办么？他说：我不知道，我不关心这个。话到这里，聊天就基本聊死了。作为长辈，虽然心里骂了他三声傻逼，可还是不忍心骂出口。 我都没法跟他讲去年我在看守*所遇到的一个哥们的故事。那哥们在深圳办了一个网络公司，也是搞三俗 的，打擦边球，靠放不露点的AV 短视频赚取网民的充值点播费，短短几个月就通过第三方支付收到几 千万的分成。结果全公司几十人被一锅端，这哥们现在面临着巨额诈骗罪起诉，在里面苦等着一审开庭。在里面经常听他闲聊创业之苦，平民百姓，无背景，无资源，赚钱难，只有捞偏门，打擦边球。只是可怜他老婆和一岁的女儿，不知道以后怎么办。每每谈及，他总是泪下。 最近和广州一个企业家朋友聊天，他做实体曾经很成功，早已亿万身价，谈及现在的经营环境，他说：现在跟我打球的老板越来越多了，大家都不知道以后该干嘛怎么干了。真是春江水暖鸭先知，谁说今天的老板们为富不仁犬儒混沌了，他们每天在泥水里打滚，水深水浅水冷水暖最敏感，珠三角的老板们都如此，其他地区的老板就不用说了。 鲁迅先生曾说：‌‌“中国历来只经历了两个时代，一个是暂时坐稳了奴隶的时代，一个是想做奴隶而不可得 的时代。‌‌”鲁夫子要是活在此时代，怕也只能再次如此感叹了，或者，他感叹都发不出了，早已经在里面啃窝窝头了。 不过，我相信在张老板此番真诚的检讨之后，他的奴才宝座暂时是可以坐稳一阵的，毕竟，乖宝宝才有好饭吃，至于以后如何，那只有天晓得了。 延伸阅读：黄云腾：告别内涵再见段友（三声） 内涵段子关停的消息，是在4月10日下午——这个平静的周二下午——传到了大伟的耳朵里。 大伟把手机打开，点击内涵段子的应用图标。手忙脚乱没有让应用打开的速度变得更快。应用上的短视频和段子依旧，不过，评论里有人证实了这个伤感的消息。有人晒出了官方通知的截图。上面写着， 由于‌‌“导向不正、格调低俗‌‌”，内涵段子将被永久关停。 永久关停——意味着‌‌“内涵段子‌‌”客户端软件及公众号将被无限期关闭。行政机构还要求内涵段子的母公司字节跳动举一反三，全面清理类似视听节目产品。 大伟今年23岁，使用内涵段子已经5年，生活在江苏无锡。这个平台确实长期存在着打擦边球的黄色或其它违规内容，是吸引很多人来到这里获得某种快乐的直接原因。 但关停的消息来得很突兀，没有人被事先通知，特别是长期乐在其中的段友。 5年时间里，大伟的闲暇时间几乎都在这款应用上度过，他会在上面看搞笑的视频和段子，和人对暗号。大伟用了自己的车之后，立即在网上买了一款‌‌“内涵段子‌‌”的车贴，贴在自己的车上。当车堵在路中间，或者需要等红灯，大伟时常可以听到同道中人在车尾鸣笛——节奏相同的、一长两短的‌‌“滴-滴滴‌‌”声。 这是段友们在人海茫茫中互相辨认的明证，也是彼此心照不宣的一张身份证。此时此刻你在微博等社交平台上，还可以搜到无数这样段友相认的视频。 5年过去了，大伟还记得自己从内涵段子认识段友，和段友见面的心情。那是一种找到了组织的感觉，就好像漂流在大海上的船只终于跟上了自己的船队。 2018年的4月，中国很多地方冷热交替，阴晴不定。有些事情的解决方案，注定是一种鸵鸟哲学。这五年时间里，大伟说，他的每一台手机，开机时装的第一个APP，都是内涵段子。 他把手机打开，发了一条微博，自从有了内涵段子，大伟已经很久没有再用微博。他写下，‌‌“你不仅仅是个app，你更是我的青春‌‌”。 ‌‌“啤酒小龙虾，段友是一家‌‌” 在7点41分的时候，段友的另一个聚集地，内涵段子贴吧里陷入一片混乱。消息已经传开。有人不愿相信，发帖还在询问，‌‌“真的就这样了吗？‌‌” 百度贴吧上，很多人也都有类似的疑问和震惊。名为‌‌“内涵段子‌‌”的百度贴吧在大伟接到消息不久后就和另外一个名为‌‌“段友之家吧‌‌”的贴吧合并，超过100万的大伟们在吧内逡巡，时不时发出‌‌“应该何去何从‌‌”的疑问和零星略显激烈的抗议声。 在两篇置顶的帖子中，其中一篇便是劝告大家理性发言。 作为今日头条的第二款独立产品，内涵段子诞生于2012年。在它诞生前后，没人可以想到这款产品可以迸发出这么大的能量，也没有人可以预估这款产品和它衍生的群体——段友，会成为中文互联网世界中一个隐秘但坚实的群体。 但是，这一切的的确确发生了。从湖南到新疆，再从山西到浙江，DJ到学生，形形色色的人都有可能是内涵段子的一份子。 4月6日，一个长沙望城的女孩在微博上晒出了望城段友聚会的视频。在这份7分钟的视频中，画面中有20余人站成一排，所有人的汽车后面都贴了内涵段子的车贴。 段友的交往方式遍布全国的各个地区社群，他们有着一套自己的社交体系和行为规矩。例如，‌‌“滴~滴滴‌‌”这个一长两短的汽车喇叭声，和内涵段子的车贴作为互相识别的标识；类似口号有‌‌“啤酒小龙虾，段友是一家‌‌”、‌‌“轻风吹杨柳，敢问是段友‌‌”、‌‌“天王盖地虎，小鸡炖蘑菇‌‌”等等。 内涵段子最开始是被设计为今日头条用户的导流入口。今日头条CEO张一鸣曾经坦言，内涵段子和它的‌‌“大哥‌‌”搞笑囧图都是这种思路的产物。 ‌‌“我们要覆盖很多形式；我们要覆盖很多平台，有手机有PC ……其实这些产品（内涵段子），都涵盖了之前的想法，只不过以一种比较接地气的想法诞生。因为当时的移动互联网发展非常快，我们希望快速推出产品，以获取用户来验证想法。‌‌” 承接百思不得姐和糗事百科的内涵段子，从一开始就立足于接地气和满足快乐。在某种程度上，这种以段子和搞笑视频为主的快乐消解了严肃的意义，从而显得low或低俗——在最大程度上，它却可以让人们拥有对同一事物的相同视角或认同感。 《内涵段子》这首歌，如今在网易云音乐上评论已经突破9000条。这首歌是内涵段子的非官方主题曲。创作者程炳杰之前是沈阳音乐学院的学生。他最初只是把这首歌上传到内涵段子里——这个集成文字、图片于一体的应用，在上线视频功能后拉动了一波上传热潮，此后让视频成为内涵段子中内容分发的主要形式。 程炳杰的歌曲最终获得了17万个赞，并因此获得了将其灌录成唱片的机会。在这首歌里，程炳杰写道，‌‌“看到段子带给我们的/不止微笑眼泪/让太多的内涵让你我体会/内涵的不止是段子还有每个人的美。‌‌” 这股凝聚力也拉动整个应用得以向社区转变。娇姐和楠哥是来自长沙的一对情侣，因为内涵段子而结识。2017年6月，他们在长沙梅溪湖进行段友聚会。一位段友带了台无人机，他们借此拿着对讲机指挥航拍汽车双闪。后来，航拍段友车队就在社区里流行起来。 他们也会一起聚起来做公益，为长沙失聪的孩子们送去玩偶公仔、课桌椅子、和画具。2017年12月，拥有900人规模的甘肃段友俱乐部来到甘肃斜坡希望小学，为学前班到六年级的孩子，带来了92套服装、68套学习用品和若干体育用品。 ‌‌“APP不在，人还在‌‌” 无论是在乐山、介休、平梁，还是新榆、铜陵，你都可以看见同样的场景：汽车的亮光打在路边，几十辆汽车排成几排，无人机在空中航拍，汽车边的人们都露出某种上扬的、熟悉的笑容。像某种回声又或者一种微弱的响应，熟悉的声音响了起来，‌‌“滴—滴滴……‌‌” 更大的不确定性一直存在于这种段友自发性的行动之中，后者也始终处于被注意的状态之下。 今天晚上20点，海门公安在微博上发布通告称，发现有部分人员通过网络召集的形式自行组织‌‌“抖友‌‌”聚集活动，活动地点均选择在道路及一些公共场所，涉嫌触犯法律。 这封通告还提到，根据《中华人民共和国集会游行示威法》，公安机关可以对负责人和直接负责人处以警告或者十五日以下拘留。 此前，西安市也曾对段友在部分路段鸣笛做出罚款处理。不过，相比这种温和的处理手段，海门似乎有意对‌‌“抖友‌‌”聚会进行定性，来将其规范在合理合规的官方体系。 今年，今日头条在官方监管中被认为具有了更强烈的危险性。从去年年底到今天，今日头条已经被官方处罚五次。今年3月29日，今日头条因为违规‌‌“二跳‌‌”，被人民日报定性为‌‌“不安分、不守法‌‌”。昨天下午3点，今日头条被要求从各互联网应用商店暂停下载。在这次处罚里，今日头条被要求暂停下载服务3周，时间从4月9日15时起至4月30日15时止。 在张一鸣的话术中，2018年本来是今日头条在社会责任发力的一年。‌‌“2018对我们已满六年的企业来说……作为一个社会的一分子，一家平台型企业来说，我们希望在企业社会责任这一块能做更多的事情。‌‌” 前不久，张一鸣在今年年初清华大学的一次分享中还谈道，‌‌“过去我们更多关心业务的成长，现在我们希望对管理团队，对业务负责人提出更高的要求。不仅关心业务，不仅关心全球化，也能够有更开阔的视角去认识、承担更多的企业社会责任。‌‌” 这个故事需要更稳定的产品壁垒和防御体系支撑。在今天晚上，人民网发布微评，‌‌“产品不能沦为算法的奴隶‌‌”，今日头条因此得到了‌‌“外科手术式‌‌”监管。以西瓜视频、火山小视频、抖音、悟空问答、内涵段子为矩阵的今日头条，也将不得不因此面临产品环节缺失与舆论审判的双重压力。 今晚，抖音发布公告称将在本周第一期反沉迷系统。用户连续使用90分钟后将被提醒用户注意时间。此外，抖音还提供由用户设定密码开启的时间锁功能，一旦单日使用时长累计达到2小时，系统将自动锁定，用户需要重新输入密码才能继续使用。 由于售假，以及多地出现模仿抖音视频受伤事件，抖音不得不采取这类应急措施，用以维护产品和正在形成的‌‌“抖友‌‌”的社群稳定。 虽然在很多段友中存在着对抖音的鄙视传统，但是在内涵段子最后的时间里，很多段友相约在抖音重逢。就在刚刚，抖音已经无法查看留言评论，也因为服务维护而参与留言。 倒回到晚上5点23分的时候，一封帖子开始得到吧友响应。那是一位吧友上传了官方通知关停的截图。这位有着7.1年吧龄的吧友，把帖子的标题取成‌‌“段友们，再最后对一遍暗号‌‌”。这就是这封帖子的全部和残留在段友们——千千万万的大伟们，眼中最后的一抹温情记忆——一切都在不言中。 现在，在内涵段子的首页是关停公告，首页的视频永远停留在了同一条，标题是‌‌“厉害了，我的…‌‌” （注：文中大伟为化名） 我们在内涵段子里看到的十句留言 ‌‌“一觉醒来，家TM没了。‌‌” ‌‌“今后唯一能笑的地方都灰飞烟灭了。‌‌” ‌‌“巅峰诞生虚伪的拥护，黄昏见证虔诚的信徒。‌‌” ‌‌“4.10内涵空难。‌‌” ‌‌“内涵段子最后一个刷新出来的是一句话，厉害了我的国。‌‌” ‌‌“我不会卸载，我等着你。‌‌” ‌‌“如果多年以后我孩子问我，爸爸内涵段子是什么组织，我会微笑并自豪着说那是我的青春。‌‌” ‌‌“内涵一日不死，抖音永远是太子，结果真的死了。‌‌” ‌‌“有多少人像我一样拿起手机不知道该干嘛了。‌‌” ‌‌“APP不在了，但是我们车友还在，路上还能遇见段友，请记住，滴~滴滴。‌‌” 结束语： 赚钱的方式永远都在刑法里，你要触动它吗？","categories":[{"name":"article","slug":"article","permalink":"http://lmwtuedu.cn/categories/article/"}],"tags":[{"name":"news","slug":"news","permalink":"http://lmwtuedu.cn/tags/news/"}],"author":"黎学文"},{"title":"Java跨平台读取本机硬件信息","slug":"2018-04-02-Java跨平台读取本机硬件信息","date":"2018-04-01T16:00:00.000Z","updated":"2019-09-17T08:16:04.058Z","comments":true,"path":"2018/04/02/2018-04-02-Java跨平台读取本机硬件信息/","link":"","permalink":"http://lmwtuedu.cn/2018/04/02/2018-04-02-Java跨平台读取本机硬件信息/","excerpt":"","text":"Java跨平台读取本机硬件信息最近做一个授权项目，需要查询各种系统的硬件信息，例如CPU、MAC等等。 于是各种google了一下，查询到了Sigar这个工具。 sigar-1.6.4.zip下载地址 maven 12345&lt;dependency&gt; &lt;groupId&gt;org.fusesource&lt;/groupId&gt; &lt;artifactId&gt;sigar&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt;&lt;/dependency&gt; 非Maven：直接拷贝下载压缩包中的Sigar.jar 到你的项目lib目录 添加sigar本地库到 java.library.pathsigar API 依赖本地库文件工作的，内部通过java.library.path加载本地库文件。 本地库文件根据不同的平台，有下面这些文件。 我试着将这些文件放在classpath下（src/main/resources）或者通过 sigar-dist 依赖的方式加载都以失败告终。网上有篇博客 讲如何通过解压 sigar-dist 依赖的方式，来组织 java.library.path，但是整个配置太过复杂。 最终我想到个办法是: 将 sigar 的本地库文件放在 src/main/resources/sigar 目录下，还是的 classpath 下通过 java api 读取 sigar 路径，并将路径追加到 java.library.path中。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940package com.darker.util.sigar;/** * helper class to check the operating system this Java VM runs in * http://stackoverflow.com/questions/228477/how-do-i-programmatically-determine-operating-system-in-java * compare to http://svn.terracotta.org/svn/tc/dso/tags/2.6.4/code/base/common/src/com/tc/util/runtime/Os.java * http://www.docjar.com/html/api/org/apache/commons/lang/SystemUtils.java.html */public final class OsCheck &#123; /** * types of Operating Systems */ public enum OSType &#123; Windows, MacOS, Linux, Other &#125; protected static OSType detectedOS; /** * detected the operating system from the os.name System property and cache * the result * * @returns - the operating system detected */ public static OSType getOperatingSystemType() &#123; if (detectedOS == null) &#123; String OS = System.getProperty(&quot;os.name&quot;, &quot;generic&quot;).toLowerCase(); if (OS.indexOf(&quot;win&quot;) &gt;= 0) &#123; detectedOS = OSType.Windows; &#125; else if ((OS.indexOf(&quot;mac&quot;) &gt;= 0) || (OS.indexOf(&quot;darwin&quot;) &gt;= 0)) &#123; detectedOS = OSType.MacOS; &#125; else if (OS.indexOf(&quot;nux&quot;) &gt;= 0) &#123; detectedOS = OSType.Linux; &#125; else &#123; detectedOS = OSType.Other; &#125; &#125; return detectedOS; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.darker.util.sigar;import com.google.common.io.Resources;import org.hyperic.sigar.Sigar;import java.io.File;import java.io.IOException;/** * @author gaohui * @date 13-11-27 19:43 */public class SigarUtil &#123; public final static Sigar sigar = initSigar(); private static Sigar initSigar() &#123; try &#123; String file = Resources.getResource(&quot;sigar/.sigar_shellrc&quot;).getFile(); File classPath = new File(file).getParentFile(); String path = System.getProperty(&quot;java.library.path&quot;); if (OsCheck.getOperatingSystemType() == OsCheck.OSType.Windows) &#123; path += &quot;;&quot; + classPath.getCanonicalPath(); &#125; else &#123; path += &quot;:&quot; + classPath.getCanonicalPath(); &#125; System.setProperty(&quot;java.library.path&quot;, path); return new Sigar(); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 思考 平常我们编译各种平台下的库时，如何解决跨平的问题？ sigar这部分的开源设计代码是否值得我们学习他的设计模式？ 参考地址sigar使用示例 java项目中使用Sigar获取系统信息 在 maven 项目中使用 sigar 源码参考","categories":[{"name":"code","slug":"code","permalink":"http://lmwtuedu.cn/categories/code/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://lmwtuedu.cn/tags/Java/"}],"author":"LJ"},{"title":"吉他的音阶","slug":"2018-04-01-吉他的音1234567的弹法","date":"2018-03-31T16:00:00.000Z","updated":"2019-09-17T08:15:26.098Z","comments":true,"path":"2018/04/01/2018-04-01-吉他的音1234567的弹法/","link":"","permalink":"http://lmwtuedu.cn/2018/04/01/2018-04-01-吉他的音1234567的弹法/","excerpt":"","text":"吉他的音1234567的弹法请看 C调音阶图： 示例：“1”的音在5弦三品上。“2”的音在5弦五品上，“3”的音在4弦二品上，“4”的音在4弦四品上，“5”的音在3弦空弦上，“6”的音在3弦二品上，“7”的音在3弦空弦上。 从上往下依次为一弦（最细）到六弦（最粗）。从左到右是一品到二十一品。 空弦音表示在此弦的空弦上弹奏左手不需要按弦。例如3弦空弦音是“5”，表示3弦空弦时拨动后发出是“5”的音。","categories":[{"name":"music","slug":"music","permalink":"http://lmwtuedu.cn/categories/music/"}],"tags":[{"name":"guitar","slug":"guitar","permalink":"http://lmwtuedu.cn/tags/guitar/"}],"author":"LJ"},{"title":"我不愿意再为谁一路小跑，气喘吁吁了","slug":"2018-03-27-我不愿意再为谁一路小跑气喘吁吁了","date":"2018-03-26T16:00:00.000Z","updated":"2019-09-17T08:14:40.332Z","comments":true,"path":"2018/03/27/2018-03-27-我不愿意再为谁一路小跑气喘吁吁了/","link":"","permalink":"http://lmwtuedu.cn/2018/03/27/2018-03-27-我不愿意再为谁一路小跑气喘吁吁了/","excerpt":"","text":"我不愿意再为谁一路小跑，气喘吁吁了讲一件真事儿。 我一个朋友，以前非常非常喜欢一个女生，在她生日的时候为了给她惊喜，把她所有的照片和视频找过来，花好长时间自学了AE软件，用眼花缭乱的特效，给她做了个片子。 他现在有钱多了，然后现在喜欢的这个女生，他也是很喜欢很喜欢的，但她生日的时候，他不做片子了，打算去网上花点钱找人做首歌送给她。 好像一首歌比一条片子更好听，也更值得发朋友圈一点儿，但他没有那种再为一个人悄悄去学一整个软件的心情了。 不是懒，也不是忙，就是……真的没有那心情了。 那个他送片子的女生，跟他告别的时候是在火车站，他舍不得她，就陪着她坐到目的地，再自己一个人坐回来。 那是很多年前，十几个小时的绿皮火车。 我猜他再也没坐过绿皮火车。确实不需要多少钱，可是坐得人太腰酸背痛了。 我是在他更有钱的时候认识的他，他至今依然是个很善良，很好的男生，也会细致入微地关心女朋友。 可我知道，从前那种日子回不来了，他不会再为谁坐十几个小时的绿皮火车了，现在这么多高铁，去哪儿都方便，那辆火车不会再开过他的心上了。 这是我近来听过的最想哭的事儿之一。 原来人的一辈子，或许就只有一个人是能让我们喜欢到极致，喜欢到歇斯底里，喜欢到可以放下一切的，经过了这个人，后来所有的付出都太礼貌，太克制，也太谨慎了。 我依然有热情余留给后来爱上的人，但我当初爱你的时候，是我这辈子最浪漫，最勇敢，也最孤注一掷的时候。 虽然那个时候，你也并没打算珍惜我。 02 我以前以为热情是可以再生的，或者说热情是用不完的，如果被一个人伤得太厉害了，就跑到下一个人那里取暖。 这样听上去很平衡，也很有盼头。 但不是这样的。 我发现我这些年，喜欢一个人的时间已经越来越短。 年轻的时候喜欢一个人，可以越挫越勇地去追，那个人我追了他一年有余，其实你问他优秀吗，并没有，但我就是喜欢，一喜欢我就收不住。 我那一年多每天花上八九个小时想念他，多难的熬煎，我走过来了。 我给他送书，指导他写作业，他睡不着，我去找晚安故事念给他听，所有的事情，只要有关他，我不嫌麻烦。 他让我在电话上唱歌给他听，我唱。他说我不是好的女生，又平庸又敏感，我认。他对我呼之即来挥之即去，我接受。 我喜欢第二个人的时间大概就几个月吧，我受不了他一直晃晃然，不给我说法，就直接跟他掰了。 那个时候我其实有大把的时间，也不是什么忙得滴水不漏的成功人士，但，我就是觉得，我开始害怕浪费时间了。 我喜欢第三个人的时间更短，人嘛，长大了，会探望本质了，知道他跟我不是一路人后，我就干干脆脆地跑回去，继续过自己每天写稿，挣钱，聚餐的日子。 你问会想他吗，会的，但是，也只有在花钱花得有点没劲儿的时候想那么几秒钟，觉得‌‌“要是他在的话，我可以抱一抱‌‌”，别的没有了。 表面上看着是我越来越无所谓，越来越刀枪不入，但不是这样的。 是我的真心快用完了。 我的浪漫快用完了，我的勇气快用完了。 我18岁可以为了一个人彻夜不眠，可以为了他去学一门乐器，什么都让着他，现在22岁就不行了，我做什么都会想问一句‌‌“凭什么‌‌”，对感情更是。 大家时间都好宝贵哦，我凭什么为你不顾一切呢？ 你说，凭什么。 03 我长大了，我知道为感情失神太徒然了，我身边全是遍体鳞伤的落败者，我自己也曾经是那个落败者。 我已经不会有从前那种，没有被任何人篡改和破坏过的完满了。 我后来喜欢的人其实都非常优秀，优秀得很值得爱，特别值得爱，但我……我身上的爱没有那么多了。 能方便一点解决的事儿，我绝对不去麻烦。 现在到处都是五花八门的app，买礼物压根不用挑，比如我再喜欢一个人的时候，要是献殷勤，最多点进一个app，帮他下单一顿早餐，反正就几十块钱。 你让我亲自赶去他楼下送给他，我是不愿意的。 但在18岁的时候，我是愿意的。 我还会一路小跑，气喘吁吁，怕手上的早餐冷掉。 不，现在我不愿意再为谁一路小跑，气喘吁吁了。 真的不愿意了。 语录：有人曾经问我，思念一个人到极致是什么感觉，我曾经在深夜里彻底的体会过，我曾在某夜给你发了一句晚安， 迟迟没有收到你的回复， 一晚上醒来七次，看着泛着白光的手机，就是 那种可怕的朦胧的意思， 梦里梦见收到你的回复 然后意识带我从梦中挣扎出来， 立马去翻看手机， 你看这就是思念入骨髓，然后尽然连梦境都不放过！ by LJ 文章转载：我不愿意再为谁一路小跑，气喘吁吁了","categories":[{"name":"article","slug":"article","permalink":"http://lmwtuedu.cn/categories/article/"}],"tags":[{"name":"news","slug":"news","permalink":"http://lmwtuedu.cn/tags/news/"}],"author":"LJ"},{"title":"lombok注解简单介绍","slug":"2018-03-26-lombok注解","date":"2018-03-25T16:00:00.000Z","updated":"2019-09-17T08:13:53.756Z","comments":true,"path":"2018/03/26/2018-03-26-lombok注解/","link":"","permalink":"http://lmwtuedu.cn/2018/03/26/2018-03-26-lombok注解/","excerpt":"","text":"lombok注解lombok是一个可以帮助我们简化java代码编写的工具类，尤其简化JavaBean的编写，即通过采用注解的方式，消除代码中的构造方法，getter/setter等代码，使我们编写的类更加简洁，当然，这带来的副作用就是不易阅读；但是还是可以看得懂，废话不多说，上干货： @NonNull @Cleanup @Getter/@Setter @ToString @EqualsAndHashCode @NoArgsConstructor/@RequiredArgsConstructor/@AllArgsConstructor @Data @Value @SneakyThrows @Synchronized @Log @NonNull这个注解可以用在成员方法或构造方法的参数前面，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，举一个例子： 1234// 成员方法参数加上@NonNull注解public String getName(@NonNull Person p)&#123; return p.getName();&#125; 效果相当于: 123456public String getName(Person p)&#123; if(null == p)&#123; throw new NullPointerException(p.toString() + &quot;is null&quot;) &#125; return p.getName();&#125; 用构造方法的参数上效果类似，就不再举例子了。 @Cleanup这个注解用在变量前面，可以保证此变量代表的资源会被自动关闭，默认是调用资源的close（）方法，如果该资源有其它关闭方法，可以使用@Cleanup(“methodName”)来指定要调用的方法，就用输入输出流来举一个例子： 123456789101112public static void main(String[] args) throws IOException&#123; @Cleanup InputStream in = new FileInputStream(args[0]); @Cleanup OutputStream out = new FileOutputStream(args[1]); byte[] b = new bytep[1024]; while(true)&#123; int r = in.read(b); if(-1 == r)&#123; break; &#125; out.write(b, 0, r); &#125;&#125; 实际效果相当于： 12345678910111213141516171819202122public static void main(String[] args) throws IOException &#123; InputStream in = new FileInputStream(args[0]); try &#123; OutputStream out = new FileOutputStream(args[1]); try &#123; byte[] b = new byte[10000]; while (true) &#123; int r = in.read(b); if (r == -1) break; out.write(b, 0, r); &#125; &#125; finally &#123; if (out != null) &#123; out.close(); &#125; &#125; &#125; finally &#123; if (in != null) &#123; in.close(); &#125; &#125;&#125; 是不是简化了很多。 @Getter/@Setter这一对注解从名字上就很好理解，用在成员变量前面，相当于为成员变量生成对应的get和set方法，同时还可以为生成的方法指定访问修饰符，当然，默认为public，直接来看下面的简单的例子： 1234567891011public class Programmer&#123; @Getter @Setter private String name; @Setter(AccessLevel.PROTECTED) private int age; @Getter(AccessLevel.PUBLIC) private String language;&#125; 效果相当于： 123456789101112131415161718192021public class Programmer&#123; private String name; private int age; private String language; public void setName(String name)&#123; this.name = name; &#125; public String getName()&#123; return name; &#125; protected void setAge(int age)&#123; this.age = age; &#125; public String getLanguage()&#123; return language; &#125;&#125; 这两个注解还可以直接用在类上，可以为此类里的所有非静态成员变量生成对应的get和set方法。 @ToString/@EqualsAndHashCode这两个注解也比较好理解，就是生成toString，equals和hashcode方法，同时后者还会生成一个canEqual方法，用于判断某个对象是否是当前类的实例，生成方法时只会使用类中的非静态和非transient成员变量，这些都比较好理解，就不举例子了。当然，这两个注解也可以添加限制条件，例如用@ToString(exclude={“param1”，“param2”})来排除param1和param2两个成员变量，或者用@ToString(of={“param1”，“param2”})来指定使用param1和param2两个成员变量，@EqualsAndHashCode注解也有同样的用法。 @NoArgsConstructor/@RequiredArgsConstructor /@AllArgsConstructor这三个注解都是用在类上的 第一个和第三个都很好理解:就是为该类产生无参的构造方法和包含所有参数的构造方法. 第二个注解则使用类中所有带有@NonNull注解的或者带有final修饰的成员变量生成对应的构造方法， 当然，和前面几个注解一样，成员变量都是非静态的，另外，如果类中含有final修饰的成员变量，是无法使用@NoArgsConstructor注解的。 三个注解都可以指定生成的构造方法的访问权限，同时，第二个注解还可以用@RequiredArgsConstructor(staticName=”methodName”)的形式生成一个指定名称的静态方法，返回一个调用相应的构造方法产生的对象，下面来看一个生动鲜活的例子： 12345678910@RequiredArgsConstructor(staticName = &quot;sunsfan&quot;)@AllArgsConstructor(access = AccessLevel.PROTECTED)@NoArgsConstructorpublic class Shape &#123; private int x; @NonNull private double y; @NonNull private String name;&#125; 实际效果相当于： 1234567891011121314151617181920212223public class Shape &#123; private int x; private double y; private String name; public Shape()&#123; &#125; protected Shape(int x,double y,String name)&#123; this.x = x; this.y = y; this.name = name; &#125; public Shape(double y,String name)&#123; this.y = y; this.name = name; &#125; public static Shape sunsfan(double y,String name)&#123; return new Shape(y,name); &#125;&#125; @Data/@Value呃!!@Data注解综合了3,4,5和6里面的@RequiredArgsConstructor注解，其中@RequiredArgsConstructor使用了类中的带有@NonNull注解的或者final修饰的成员变量，它可以使用@Data(staticConstructor=”methodName”)来生成一个静态方法，返回一个调用相应的构造方法产生的对象。这个例子就也省略了吧…@Value注解和@Data类似，区别在于它会把所有成员变量默认定义为private final修饰，并且不会生成set方法。 @SneakyThrows这个注解用在方法上，可以将方法中的代码用try-catch语句包裹起来，捕获异常并在catch中用Lombok.sneakyThrow(e)把异常抛出，可以使用@SneakyThrows(Exception.class)的形式指定抛出哪种异常，很简单的注解，直接看个例子： 1234567891011public class SneakyThrows implements Runnable &#123; @SneakyThrows(UnsupportedEncodingException.class) public String utf8ToString(byte[] bytes) &#123; return new String(bytes, &quot;UTF-8&quot;); &#125; @SneakyThrows public void run() &#123; throw new Throwable(); &#125;&#125; 实际效果相当于： 12345678910111213141516171819public class SneakyThrows implements Runnable &#123; @SneakyThrows(UnsupportedEncodingException.class) public String utf8ToString(byte[] bytes) &#123; try&#123; return new String(bytes, &quot;UTF-8&quot;); &#125;catch(UnsupportedEncodingException uee)&#123; throw Lombok.sneakyThrow(uee); &#125; &#125; @SneakyThrows public void run() &#123; try&#123; throw new Throwable(); &#125;catch(Throwable t)&#123; throw Lombok.sneakyThrow(t); &#125; &#125;&#125; @Synchronized这个注解用在类方法或者实例方法上，效果和synchronized关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized关键字的锁对象分别是类的class对象和this对象，而@Synchronized得锁对象分别是私有静态final对象LOCK和私有final对象lock，当然，也可以自己指定锁对象，例子也很简单，往下看： 123456789101112131415161718public class Synchronized &#123; private final Object readLock = new Object(); @Synchronized public static void hello() &#123; System.out.println(&quot;world&quot;); &#125; @Synchronized public int answerToLife() &#123; return 42; &#125; @Synchronized(&quot;readLock&quot;) public void foo() &#123; System.out.println(&quot;bar&quot;); &#125;&#125; 实际效果相当于： 1234567891011121314151617181920212223public class Synchronized &#123; private static final Object $LOCK = new Object[0]; private final Object $lock = new Object[0]; private final Object readLock = new Object(); public static void hello() &#123; synchronized($LOCK) &#123; System.out.println(&quot;world&quot;); &#125; &#125; public int answerToLife() &#123; synchronized($lock) &#123; return 42; &#125; &#125; public void foo() &#123; synchronized(readLock) &#123; System.out.println(&quot;bar&quot;); &#125; &#125; &#125; @Log这个注解用在类上，可以省去从日志工厂生成日志对象这一步，直接进行日志记录，具体注解根据日志工具的不同而不同，同时，可以在注解中使用topic来指定生成log对象时的类名。不同的日志注解总结如下(上面是注解，下面是实际作用)： 1234567891011121314@CommonsLogprivate static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);@JBossLogprivate static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);@Logprivate static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());@Log4jprivate static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);@Log4j2private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);@Slf4jprivate static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);@XSlf4jprivate static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class); 关于lombok的注解先写到这里，当然，还有其他一些注解需要大家自己去摸索，同时lombok一直在扩展，将来肯定会加入更多的注解元素，拭目以待了。 转载：lombok注解介绍","categories":[{"name":"code","slug":"code","permalink":"http://lmwtuedu.cn/categories/code/"}],"tags":[{"name":"lombok","slug":"lombok","permalink":"http://lmwtuedu.cn/tags/lombok/"}],"author":"LJ"},{"title":"分布式设计架构初步思路","slug":"2018-03-05-分布设计架构思路","date":"2018-03-04T16:00:00.000Z","updated":"2019-09-17T08:13:38.348Z","comments":true,"path":"2018/03/05/2018-03-05-分布设计架构思路/","link":"","permalink":"http://lmwtuedu.cn/2018/03/05/2018-03-05-分布设计架构思路/","excerpt":"","text":"分布设计架构思路初步设计网站的访问特点和现实世界的财富分配一样遵循二八定律： 80%的业务访问集中在20%的数据上。既然大部分的业务访问集中在一小部分的数据上，那么如果把这一小部分数据缓存在内存中，是不是可以减少数据库的访问压力呢？ 提高整个网站的数据访问速度，改善数据库的写入性能呢？ 网站使用的缓存可以分为两种： 缓存在应用服务器上的本地缓存和缓存在专门的分布式缓存服务器上的远程缓存。本地缓存的访问速度更快些，但是受应用服务器内存的限制，其缓存数量有限，而且会出现和应用程序争用内存的情况。 远程分布式缓存可以使用集群的方式，部署大内存的服务器作为专门的缓存服务器，可以理论上做到不受内存容量限制的缓存服务。 使用缓存后，数据访问的压力得到有效的缓解，但是单一应用服务器能够处理的请求连接有限；在网站访问的高峰期，应用服务器成为整个网站的瓶颈。 进一步提升（应用集群）应用服务器集群改善网站的并发处理能力，使用集群时网站解决高并发、海量数据问题的常用手段。当一台服务器的处理能力、存储空间不足时，不要企图去换更强大的服务器，对大型网站而言，不管多么强大的服务器，都满足不了网站持续增长的业务需求。这种情况下，更恰当的做法是增加一台服务器分担原有服务器的访问以及存储压力。 对网站架构而言，只要能通过增加一台服务器的方式改善负载压力，就可以以同样的方式持续增加服务器不断改善系统性能，从而实现系统的可伸缩性。应用系统服务器实现集群时网站可伸缩集群架构设计中较为简单成熟的一种。 通过负载均衡调度器，可以将用户浏览器的访问请求分发到应用服务器集群中的任何一台服务器上，如果有更多的用户，就在集群中加入更多的应用服务器，使应用服务器的负载压力不再成为网站的瓶颈。 进一步升级（数据库读写分离）网站使用缓存后，绝大部分数据读操作访问都可以不通过数据库就能够完成，但是仍有一部分读操作（缓存访问不命中、缓存过期）和全部的写操作都需要访问数据库，在网站到达一定规模后，数据库因为负载压力过高而成为网站的瓶颈。 目前大部分的主流数据库都是提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。网站利用数据库的这一功能，实现数据库读写分离，从而改善数据库负载压力。 应用服务器在写数据的时候，访问主数据库，主数据库通过主从复制机制将数据库更新同步到从数据库，这样当应用服务器读数据的时候，就可以通过从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离对应用透明。 再次简单升级（反向代理和CDN加速网站响应）用户规模越来越大，由于中国的复杂网络环境，不同地区的用户访问网站时，速度差别也极大。数据显示： 网站访问延迟和用户流失率正相关，网站访问越慢，用户越容易失去耐心而离开。 为了提供更好的用户体验，留在用户，需要加速网站访问速度。 主要手段使用CDN和反向代理。 反向代理和CDN的基本原理是缓存，区别在于CDN部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据； 而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。 再次升级（分布式文件/分布式数据库）数据库经过读写分离后，从一台服务器拆分成两台服务器，但是随着网站业务的发展依然不能满足，这时需要使用分布式数据库。 文件系统也是一样，需要使用分布式系统。 分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段时业务分库，将不同业务的数据部署在不同的物理服务器上。 优化设计（NoSQL和搜索引擎）随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂化，网站需要采用一些非关系数据技术如NoSQL和非数据库查询技术如搜索引擎。 NoSQL和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特效具有更好的支持。 应用服务器则通过一个统一数据访问模块访问各种数据，减少应用程序管理的诸多数据源的麻烦。 拆分设计（业务拆分）大型网站为了应对日益复杂的业务场景，通过使用分而治之的手段将整个网站业务分成不同的产品线。 具体到技术上，将一个网站拆分成为许多不同的应用（有点微服务器的感觉）， 每个应用独立部署维护。 应用之间可以通过一个超链接建立关系（在首页上的导航链接每个都指向不同的应用地址），也可以通过消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构建一个关联的完整系统。 分布式服务由于所有应用要和所有数据库系统连接，在数万台服务器规模的网站中，这些连接的数目是服务器规模的平方，导致存数据库接资源不足，拒绝服务。 既然每一个应用都需要执行相同的业务操作，比如： 用户管理、商品管理等，那么可以将这些共有的业务提取出来，独立部署。 由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共有业务服务完成具体业务操作。 书籍参考： 大型网站架构核心原理与解析","categories":[{"name":"framework","slug":"framework","permalink":"http://lmwtuedu.cn/categories/framework/"}],"tags":[{"name":"framework","slug":"framework","permalink":"http://lmwtuedu.cn/tags/framework/"}],"author":"LJ"},{"title":"当前流行的一些软件保护技术","slug":"2018-03-02-当前流行-的一些软件保护技术","date":"2018-03-01T16:00:00.000Z","updated":"2019-09-17T08:12:56.264Z","comments":true,"path":"2018/03/02/2018-03-02-当前流行-的一些软件保护技术/","link":"","permalink":"http://lmwtuedu.cn/2018/03/02/2018-03-02-当前流行-的一些软件保护技术/","excerpt":"","text":"当前流行的一些软件保护技术序列号保护数学算法一项都是密码加密的核心，但在一般的软件加密中，它似乎并不太为人们关心，因为大多数时候软件加密本身实现的都是一种编程技巧。 但近几年来随着序列号加密程序的普及，数学算法在软件加密中的比重似乎是越来越大了。 看看在网络上大行其道的序列号加密的工作原理。当用户从网络上下载某个shareware——共享软件后，一般都有使用时间上的限制，当过了共享软件的试用期后，你必须到这个软件的公司去注册后方能继续使用。注册过程一般是用户把自己的私人信息（一般主要指名字）连同信用卡号码告诉软件公司，软件公司会根据用户的信息计算出一个序列号，在用户得到这个序列号后，按照注册需要的步骤在软件中输入注册信息和注册码，其注册信息的合法性由软件验证通过后，软件就会取消本身的各种限制，这种加密实现起来比较简单，不需要额外的成本，用户购买也非常方便，在互联网上的软件80%都是以这种方式来保护的。 软件验证序列号的合法性过程，其实就是验证用户名和序列号之间的换算关系是否正确的过程。其验证最基本有两种，一种是按照用户输入的姓名来生成注册码，再同用户输入的注册码比较，公式表示如下： 1序列哈 = F(用户名) 这种方法等于在用户软件中再现了软件公司生产注册码的过程，实际上是非常不安全的，不论其过程是多么的复杂，解密者只需把你的换算过程从程序中提取出来就可以编制一个通用的注册程序。 另外一种是通过注册码来验证用户名的正确性，公式表示如下： 1用户名称 = F逆（序列号）（如 ACDSEE） 这其实是软件公司注册码计算过程的反算法，如果正向算法与反向算法不是对称算法的话，对于解密者来说，的确有些困难，但这种算法相当不好设计。 于是有人考虑以下的算法： 1F1(用户名称) = F2（序列号） F1、F21是两种完全不同的算法，但用户名通过F1算法计算出的特征字等于序列号通过F2计算出的特征字，这种算法在设计上比较简单，保密性相对以上两种算法也要好的多，如果能够把F1、F2算法设计成不可逆算法的话，保密性相当的好；可一旦解密者找到其中之一的反算法的话，这种算法就不安全了，一元算法的设计看来再如何努力也很难有太大的突破，那么二元呢？ 1特定值 = F(用户名，序列号) 这个算法看上去相当不错，用户名称和序列号之间的关系不再那么清晰了，但同时也失去了用户名与序列号的一一对应关系，软件开发者必须自己维护用户名称与序列号之间的唯一性，但这似乎不是难以办到的事，建立一个数据库就可以了。当然也可以把用户名称和序列号分为几部分来构造多元的算法。 1特定值 = F（用户名1， 用户名2， ···， 序列号1， 序列号2， ····） 现有的序列号加密算法大多是软件开发者自行设计的，大部分相当简单。而且有些算法作者虽然下了很大的功夫，效果却往往得不到它所希望的结果。 时间限制 有些程序的试用版每次运行都有时间限制，例如运行10分钟或20分钟就停止工作，必须重新运行该程序才能正常工作。这些程序里面自然有个定时器来统计程序运行的时间。 这种方法使用的较少。 Key File 保护Key File（注册文件）是一种利用文件来注册软件的保护方式。 Key File一般是一个文件，可以是纯文本文件，也可以是包含不可显示字符的二进制文件，其内容是一些加密过或未加密的数据。其中可能有用户名、注册码等信息。 文件格式则由软件作者自己定义。试用版软件没有注册文件，当用户向作者付费之后，会收到作者寄来的注册文件，其中可能包含用户的个人信息。用户只要将该文件放入指定目录，就可以让软件成为正式版。该文件一般是放在软件的安装目录中或者系统目录下。软件每次启动时，从该文件中读取数据，然后利用某种算法进行处理，根据处理的结果判断是否为正确的注册文件，如果正确则注册版模式来运行。 这种保护方法使用也不多 CD-check（基本淘汰） 即光盘保护技术。程序在启动时判断光驱中的光盘上是否存在特定的文件，如果不存在则认为用户没有正版光盘，拒绝运行。在程序运行的过程当中一般不再检查光盘的存在与否。Windows下的具体实现一般是这样的：先用GetLogicalDriveStrings（ ）或GetLogicalDrives（ ）得到系统中安装的所有驱动器的列表，然后再用GetDriveType（ ）检查每一个驱动器，如果是光驱则用CreateFileA（ ）或FindFirstFileA（ ）等函数检查特定的文件存在与否，并可能进一步地检查文件的属性、大小、内容等。 软件狗 软件狗是一种智能型加密工具。它是一个安装在并口，串口等接口上的硬件电路，同时有一套使用各种语言的接口软件和工具软件。当被狗保护的软件运行时，程序向插在计算机上的软件狗发出查询命令，软件狗迅速计算查询并给出响应，正确的响应保证软件继续运行。如果没有软件狗，程序将不能运行，复杂的软硬件技术结合在一起防止软件盗版。真正有商业价值得软件一般都用软件狗来保护。 平时常见的狗主要有“洋狗”（国外狗）和“土狗”（国产狗）。这里“洋狗”主要指美国的彩虹和以色列的HASP，“土狗”主要有金天地（现在与美国彩虹合资，叫“彩虹天地”）、深思、尖石。总的说来，“洋狗”在软件接口、加壳、反跟踪等“软”方面没有“土狗”好，但在硬件上破解难度非常大；而“土狗”在软的方面做的很好，但在硬件上不如“洋狗”，稍有单片机功力的人，都可以复制。 软盘加密 通过在软盘上格式化一些非标准磁道，在这些磁道上写入一些数据，如软件的解密密钥等等。这种软盘成为“钥匙盘”。软件运行时用户将软盘插入，软件读取这些磁道中的数据，判断是否合法的“钥匙盘”。 软盘加密还有其它一些技术，如弱位加密等等。 随着近年来软盘的没落，这种方法基本上退出了历史舞台。 将软件与机器硬件信息结合用户得到（买到或从网上下载）软件后，安装时，软件从用户的机器上取得该机器的一些硬件信息（如硬盘序列号，BOIS序列号等等），然后把这些信息和用户的序列号、用户名等进行计算，从而在一定程度上将软件和硬件部分绑定。用户需要把这一序列号用Email、电话或邮寄等方式给软件供应商，软件开发商利用注册机（软件）产生该软件的注册号寄给用户即可。软件加密虽然加密强度比硬件方法较弱，但它具有非常廉价的成本、方便的使用方法等优点。非常适合作为采用光盘（CDROM）等方式发授软件的加密方案。 此种加密算法的优点： 不同机器注册码不同。用户获得一个密码只能在一台机器上注册使用软件。不同于目前大多软件采用的注册方法，即只要知道注册码，可在任何机器上安装注册。 不需要任何硬件或软盘 可以选择控制软件运行在什么机器、运行多长时间或次数等 可让软件在不注册的功能为演示软件，只能运行一段时间或部分功能。注册后立即变成为正式软件 采用特别技术，解密者很难找到产生注册码的规律 在使用注册码产生软件（注册机）时可以采用使用密码、密码盘、总次数限制等方法。 方便易用，价格低廉。 这种加密还有以下特点： 注册加密的软件，只能在一台机器上安装使用。把软件拷贝到其它机器上不能运行。 若用户想在另一台机器上安装运行，必须把软件在这台机器上运行的序列号，寄送给软件出版商换取注册码，当然再交一份软件费用。 此加密方法特别适应在因特网上发布的软件以及光盘发布的软件。 软件加密技术和注册机制 授权验证特性 RSA非对称加密，公钥加密，私钥解密，保证license信息安全。 私钥签名公钥验证，数字签名：防止license被冒充签发（认证）； 保证数据完整性； 数字签名具有不可抵赖性（即不可否认性）。 硬件信息采集，防止程序被无限拷贝。 授权截止时间，完成业务上授权需求。 使用license的业务代码混淆加密，防止反编译替换跳过验证流程。（其实看设计的复杂程度，破解只是时间问题） 可以加入自定义数据（授权版本、授权对象、授权功能列表）等等，方便扩展。 流程图","categories":[{"name":"code","slug":"code","permalink":"http://lmwtuedu.cn/categories/code/"}],"tags":[{"name":"safe","slug":"safe","permalink":"http://lmwtuedu.cn/tags/safe/"}],"author":"LJ"},{"title":"QPS、PV、RT（响应时间）之间的关系","slug":"2018-02-27-QPS、PV、RT（响应时间）之间的关系","date":"2018-02-26T16:00:00.000Z","updated":"2019-09-17T08:12:29.142Z","comments":true,"path":"2018/02/27/2018-02-27-QPS、PV、RT（响应时间）之间的关系/","link":"","permalink":"http://lmwtuedu.cn/2018/02/27/2018-02-27-QPS、PV、RT（响应时间）之间的关系/","excerpt":"","text":"QPS、PV、RT（响应时间）之间的关系在进行系统性能压测和系统性能优化的时候，会涉及到QPS、PV、RT相关的概念。 QPSQPS： query per seconds 单个进程每秒请求服务器的成功次数 QPS = rep/sec = 请求数/秒 QPS如何统计？QPS统计方式【一般使用http_load进行统计】 QPS= 总请求数 /（进程总数*请求时间） 根据QPS推算PV单台服务器每天PV计算公式1: 每天总PV = QPS36006公式2: 每天总PV = QPS36008 根据QPS、PV推算服务器数量服务器数量 = 每天总PV / 单台服务器每天总PV 峰值QPS和机器计算公式： 原理： 每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间 峰值时间每秒请求数（QPS）： （总PV数 * 80%）/（每天秒数*20%） 峰值机器数量： 峰值时间QPS / 单台机器的QPS 例子： Q： 每天300W PV的在单台机器上，这台机器需要多少QPS？ A： （3000000 * 0.8）/（86400 * 0.2） = 139（QPS） Q： 如果一台机器的QPS是58， 需要几台机器来支持？ A： 139/58 = 3 最佳线程数性能压测的情况下, 起初随着用户的增加， QPS会上升，当到了一定的阀值之后，用户数量增加QPS并不会增加，或者增加不明显，同时请求的响应时间却大幅增加，这个阀值我们认为是最佳线程数。 为什么要找最佳线程数？ 过多的线程只会造成，更多的内存开销，更多的CPU开销，但是对提升QPS确毫无帮助 找到最佳线程数后通过简单的设置，可以让web系统更加稳定，得到最高、最稳定的QPS输出。 最佳线程数的获取： 通过用户慢慢递增来进行性能压测，观察QPS，响应时间 根据公式计算： 服务器端最佳线程数量 = （（线程等待时间 + 线程CPU时间）/（线程CPU时间））* cpu数量 单用户压测，查看CPU的消耗，然后直接乘以百分比，再进行压测，一般这个值的附近应该就是最佳线程数量。 影响最佳线程数的主要因素 IO IO开销较多的应用，其CPU线程等待时间会比较长，所以线程数量可以开的多一些，相反则线程数量要少一些， 其实有两种极端，纯IO的应用，比如 proxy， 则线程数量可以开到非常大（实在太大了则需要考虑线程切换的开销），这种应用基本上后端（比如这个proxy是代理搜索的）的QPS能有多少， proxy就有多少。 CPU 对于耗CPU的计算，这种情况一般来讲只能开到CPU个数的线程数量。但是并不是说这种应用的QPS就不高，往往这种应用QPS可以很高，因为耗CPU计算的应用，往往处理单次请求的时间会很短。 QPS和线程数的关系 在最佳线程数量之前，QPS和线程是相互递增的关系，线程数量到了最佳线程之后，QPS持平，不在上升，甚至略有下降，同时响应时间持续上升。 同一个系统而言，最佳线程数越多，QPS越高。","categories":[{"name":"code","slug":"code","permalink":"http://lmwtuedu.cn/categories/code/"}],"tags":[{"name":"QPS","slug":"QPS","permalink":"http://lmwtuedu.cn/tags/QPS/"},{"name":"PV","slug":"PV","permalink":"http://lmwtuedu.cn/tags/PV/"},{"name":"RT","slug":"RT","permalink":"http://lmwtuedu.cn/tags/RT/"}],"author":"LJ"},{"title":"华为13年：工作不如房子赚的多","slug":"2018-02-24-工作不如房子赚的多","date":"2018-02-23T16:00:00.000Z","updated":"2019-09-17T08:11:33.371Z","comments":true,"path":"2018/02/24/2018-02-24-工作不如房子赚的多/","link":"","permalink":"http://lmwtuedu.cn/2018/02/24/2018-02-24-工作不如房子赚的多/","excerpt":"","text":"华为13年：工作不如房子赚的多提离职已经过去十几天了，马上就到入职13周年纪念日了，最好的青春年华都贡献给这里了，这两天也不忙了，还是记录下这段时光：一来娱乐下大家，二来是给将来的自己一个回忆。 提前声明：楼主在华为算是混得不好的，仅到17A，工资不到3万，股票+TUP只有十几万。经历及思考未必有有很多参考价值，慎入… 如果说只能留下一句话给兄弟们，那就是：不管是出于生计、理想、情怀等等任何原因，如果能逼自己在华为全力以赴、全情投入地工作，那就可以继续留下来；如果不能做到竭尽全力，一直三心二意，那就赶紧换工作吧，不然真的是在浪费自己的生命，将来很大概率会后悔。不幸的是，楼主就属于后者，如果不是在其他投资上狗屎运好，那就是一个悲剧。 先介绍下楼主家庭背景（这个背景影响了楼主后面很多决定，也注定了楼主在华为的最终宿命）：出生于闽南农村，成长于小县城，家庭物质环境不好不坏，没有吃过苦也没有奢华过，大家庭，两亲哥两亲姐一妹妹。重点是：身边的七大姑八大姨及他们的孩子们大都读书不好，上不了大学（我算是学历最好的了），基本无正式工作，大都是做各种乱七八糟生意，很大比例混得也还不错。 1.第一份工作（厦门夏新）： 如果你知道这家公司，那说明你可能年纪不小了：），03年毕业，那会的想法很简单，回到南方搞科研，深圳、广州、厦门都在范围之内。那年华为是不招人（刚经过泡沫还没有缓过来），最牛B的是UT斯达康和上海迪比特手机，可以开到六七K的月薪，以我没过四级的英语估计也不要我，又在杭州、上海。深圳是被康佳拒绝了，广州是被南方高科拒绝了，其他的不记得了，最后去了厦门夏新电子，月薪2.5K，在厦门这个地方每个月是亏钱。 慢慢的精神上开始受各种折磨，不是来自工作上的，是来自家乡那些没有上学的部分小伙伴，很多做生意、倒买倒卖、坑蒙拐骗已经混得很好了。一年后，我很想加入他们的大军，家里人委婉的表示不赞同，觉得好不容易读书出来，再回去做那些事太不应该了，我记得那是第一次为自己钱途迷茫哭了。好吧，那就换工作吧，等将来再出来做生意（这个想法严重影响了我在华为的奋斗动力和成果），夏新绝对是离死不远了，那会深圳已经表现出比厦门好很多的潜力了，可选择的好公司也多了好多，自然是首选。 投了三家公司的研发岗位，中兴+腾讯+华为，中兴说只招社招毕业三年的，被拒了。华为很快就来厦门面试了，是核心网固定软交换研发，同批面试的8个人，几轮面试之后有我一个人入职这个部门。腾讯只搞了两轮电话面试，在我到百草园报到之后的第二天给发了Offer：手机游戏开发，月薪6.2K。华为给的是3.8+1K，没有转身去腾讯，是觉得华为有技术、有核心竞争力，不在乎这1.4K的差距，这又是一个傻的想法。 看到这里，各位看官觉得我的选择错误还是选择正确呢？手机、游戏、腾讯、华为这四个词随便组合在此后的十年直到今天，都是炙手可热，反观我最终入行的电信行业则江河日下。一时的得失真的不知道是不是塞翁失马焉知非福，这么多年来，我基本可以做到从不为打翻的牛奶哭泣，包括后面说的投资上的失误，是会偶尔有后悔，但是痛苦时间绝对是短暂的，很快就可以用阿Q精神安慰自己放下那些事。 04年底面试上华为，为了等夏新年终奖，拖到了05年3月才入职，这又是一个鼠目寸光的决定，那七千块跟华为的三个月资历比起来实在是捡了芝麻丢了西瓜。离开厦门的时候，整整工作了一年半，是负资产状态离开的。 2.在华为研发，痛并快乐着（四年多，2005-09）： 前面半年的工作实在是枯燥无味，入职半年后开始有一些国内出差的机会，应该是期间表现不错，05年底被领导派去拉美守局半年。这个是在华为最爽、最重要的一次出差，因为那6万块钱出差补助，加上05年不到2万的年终奖及家里赞助的一点钱，凑了12万块钱在06年10月买了人生第一套房（龙华民治春华四季园75平+赠送30多平，三房一厅一卫，总价57万，首付两成）；那会真心不知道房产投资是这么重要，只是对居住环境有点挑剔，觉得买房会生活得更好，也觉得房子跟其他东西一样肯定也不会降价。说到这里，有个建议：任何时候都尽量不要委屈自己，过好点生活，保证自己将来不后悔。如果居住对你很重要就住好点，如果吃好东西能提升幸福感就使劲吃，如果一两件奢侈品能让你开心很久，也不是不能买。当然，如果对你无关紧要的东西，就不要浪费，比如吃好东西对我就没有什么吸引力，我可以连续一个月吃相同的面包牛奶早餐。刚来深圳，住了三个月岗头，实在是受不了，试用期满了就搬去上梅林，虽然也是农民房，但是有电梯、新房啊，而且周边干净方便啊，含水电网每月1400，那会我的工资税后是4100，买了房子月供2700，两项直接月光，开始靠年终奖、出差补助吃饭。关于工资，05年入职4800，很长时间处于倒挂状态，好像到了06年低才开始加薪，具体不记得了。 2007年中，开始在研发带小团队，那会叫PL，职级好像也调到14级，工资涨到了七千出头。做了这个小PL之后，项目组只要有人加班，你就要陪着。天天加班，加上在研发的晋升路线太过于清晰了，实在不是我想要的，加上我自己设置的岗位路线是做销售、是出国去。坚持了两年后实在是扛不住了，09年初跟领导提出要换部门去MKT，那会的PDT经理应该是有些惊讶、失望，因为那会我算是几个PL里做的不错的，他估计觉得待我不薄。 09年4月份安排我去美国出差三个月支持Comcast项目，美国出差回来后被安排去了市场技术组，很快，同年十月公司要求研发市场技术相关人员全部切换到MKT MO，我自然而然的就过去了，有时候我觉得上天对我很好，基本是想去哪里，机会就来了，后面还有几次这种事。 这段时间的财务状况是：持续月光。08年中工资到了8500，09年底来到了9000。年终奖好像是06年3万，07年5.5万左右，08年好像是保持不变（因为09年初我就提出来换部门要求了）。股票好像是只有两三万股，真心不太记得了，反正全是最大值贷款。08年初花了近二十多万装修，还买了十二三万的小车，也全部是分期贷款。（那会并不是说很有理财头脑，只是不想降低自己的生活质量，老家里也没有啥大负担，就死命贷款。）08年还结了婚，老婆是慧通的，收入不高，牛B的是超级支持我后面的各种借钱、贷款、折腾，欠债比我还没压力，没有任何扯后腿行为，有时比我还激进。 说到贷款值得提下在华为的另外一段经历：09年（or10年），惊奇地发现招商银行可以提供信用贷款，利息也很低。这对于我来说简直就是送钱啊，身边做生意的亲人、同学在社会上借钱的利息都在18%以上，还不容易拿到。我开始挨家挨家银行问，搞下来不少贷款，转手18%借给亲人和同学，赚利息差。后来想华为这么多有钱人，好多人都不投资，把钱存银行，为什么不用起来呢。开始给认识的熟人群发邮件，开10%年息借钱，一年一签，要求提前赎回就扣除一个月利息，我主动提前还钱多给一个月利息。可能是在同事中信用还行，还真的有不少人把十万二十万的借给我。第一次体会到用钱生钱的妙不可言。这个生意一直持续到12年底我去海外常驻，开始慢慢减少，原因有二：一是需要用钱的亲人朋友也少了一些，二是人在海外跟同事签署借贷合同不那么方便了。这个过程对我十分珍贵，算是我用银行钱空手套白狼的启蒙尝试。过去二十年存钱的人是吃亏的，相信未来一百年也依然是如此，珍惜在华为这个身份能给大家带来的无数信用贷款的隐形福利，不要浪费了，至于是投房产、股票、P2P还是其他，只能是八仙过海各显神通了。 另外一个建议是：当时借给我钱的人，大多是一些比较大胆、开放、有极强赚钱欲望的人，这几年观察下来，这些人在后面的炒房、投资中平均收益比平均值高很多。这个世界坐等是不会有钱来的，社会资讯也很多，开放点，多了解、接触这个社会，只有不断折腾、不断尝试才会有惊喜，还有就是永远不要歧视赚小钱的机会，小钱都赚不到，赚大钱不是更难，任何赚钱的行为都是在培养人的思维和习惯！供参考。 3.在华为Marketing，堕落的开始（三年，2009-12）： “Marketing/市场营销”，像运营商这种一个国家用指头都能数出来的客户是真心不需要营销，华为研发、MKT、行销里，MKT是最没有存在感，有时候连背锅都不够格。这个就是为什么我说换部门时想来MKT是一个很SB的选择。 唯一值得回忆的是，在MKT我发现了另外一条赚外快之路，09/10年左右，团购概念风生水起，各路卖水果、买衣服的都开始以团购之名促销了。耶，我们家是铁观音之乡啊，开始试水在同事间组织铁观音茶叶团购，试水几次发现需求还挺旺盛的，就例行持续做了起来。那会经常中午不睡觉开着车在坂田各大区域停车场定点送茶叶，每斤赚的钱其实不多，但是做的很开心的，这应该算是第一次验证我更喜欢倒买倒卖的本性。这个生意一直持续到出国后一年，后来公司改notes到Outlook，不能做便捷的傻瓜式点击订购按钮了，产品也没有怎么推陈出新，在国外远程运作也不方便，慢慢的就没搞了。 到了12年初的时候，已经在MKT待的很烦了，女儿11年底也出生了，觉得是时候整点变化，比如出国去，想带老婆孩子出去体验几年，也符合自己当初的规划。因为要带家属，必须是发达国家，首选是英语国家。正好有个西欧的MKT同事要回来，MO外籍领导很开明，就同意我去置换了。 这段时间的财务状况：保持月光直到12年初，因为08/09年底贷款都是2-3年期的还款，加上少量公司配股侵蚀部分资金。10年中工资到近1万，11年初到1万1千多。已经不记得那几年的年终奖了，应该都是5-8万之间徘徊，好像没有拿到过更多。股票好像也就只有六七万股，不太记得了，职级也仅仅到15级。到了12年初，除了三十年期的房贷、公司股票贷款没有提前还，装修贷、车贷刚刚还完。想着外派每个月会带来每月近1万的离家补助、据说奖金也会多些，怎么也得在出去前把这些钱安排出去，不能存在银行浪费，开始找投资渠道。同期，惊奇地发现信用贷款开始泛滥，贷款中介开始出现（或者早就有了，只是那会才大量联系我），加上中介说假离婚证就可以三成首付，连同假收入证明、工资流水200块就可以买到，隐约感觉国家又在搞经济刺激了，房价是不是要涨？加上研究了半天也没有想出什么其他投资渠道来，觉得还是房地产靠谱。 兼顾投资和将来自住需求，最终锁定了龙华红山那片，基本理由是：1）龙华新区刚成立，总要找个地方出政绩，空地比老旧城区好折腾多了；2）北站周边至少有人流量保证吧；3）从在深圳地图看，这个地方真的是中心啊，去那里都是可以的，表示福田、南山、罗湖的屌丝都可以是接盘侠啊（这个选址逻辑我认为至今仍然可用，故高亮）。至于后面高级中学北校区学位加身，那纯粹是狗屎运好；12年6月用自己仅有的10万存款+45万信用贷款三成首付（假离婚证、老婆名义）买入水榭春天五期88平+赠送25平总价157万。这应该是我最狗屎运的一笔投资，10万自有资金+后面两年半还信贷50多万+两年持续按揭（一年半后收房花了10万装修出租五千多每月，快要抵“30年期/85折利率”的月供）换来17年底690万卖出。 一点思考：房产投资非常粗暴地证明一个人所处环境和眼界是多么的重要。稍微了解深圳房地产的人应该清楚过去十年，屌丝逆序最成功的片区是宝安中心区，其次才是龙华红山之类的。为什么这么多牛B的华为人选择在坂田、布吉甚至龙岗置业呢？不是我们比别人笨，是繁忙的工作、有限的交际圈子、生活所在地限制了眼界。如果你不是住在南山的有钱老员工，如果你没有女朋友在南山上班而了解那边，你首次置业还能有眼光去宝中，那真的是天纵奇才。老板讲话说深圳市中心必然北移，大家现在还信吗？不客气地说，二十年前，华为基地地址如果选在宝安那边，华为屌丝们的平均身家至少增加30%。当然，对公司来说，远离南山是好的，少了很多诱惑，锁住无数人跳槽！ 一个抢房Tip共享（对实名登记的就无效了）： 水榭房子开盘的时候，还是要抢的。我提前列一个标的优先级就去现场，每人领一个组号，抽签一组一组进，希望其实挺渺茫的。开场后，主持人说：每个中签人员最多两人同行进去选房。听到这句话，肾上腺激素立刻飙升，直接去了入口处。第一组进去的人保安看得很紧，没行动。第二组的时候，我远远看到一个中签且是单人行的哥们，迎了上去，甩出五张百元大钞：“哥，带我一起进去，这钱归你了”（换做是我，我也会带进去，多一个人抢房根本影响不了啥）。我就这样第二组进去选到了目标清单中的房子。 4.在华为西欧，5年幸福时光。。。（2012-17） 12年底顺利到了德国常驻，隶属地区部核心网MKT，接替的同事是做品牌，顺理成章继续做品牌为主的工作，这个压力小、边沿化的岗位让我在西欧过了五年轻松日子，但相应的也葬送了我在华为往核心岗位（行销及客户线）转身的意志力和可能性。五年间，因为英语不好加上在品牌部工作毫无压力，我没有提出转行销的要求，而MKT部门有多鸡肋前面已经说过了，在地区部更是如此。 不过也有悲催的一面，有句鸡汤其实很有道理：“人无近虑，必有远忧（改编版），你每天过得很轻松，说明你在走下坡路，你每天都在拼命，说明你在走上坡路”。这句话确实很大概率会应验。因为在MKT品牌部的如鱼得水，让自己放弃了当初做一个“销售”的理想，远离了华为的主航道，不只是上升空间有限，自己的能力积累也是有限的。 德国作为老牌资本主义国家，在这里生活久了，是真的觉得这个国家的软能力超强、社会运作效率其实很高、运作成本很低，举个例子：淘宝支付宝建立起来的买、卖双方信任体系提升了中国人民在购物这个事上多少效率、便利性，而德国整个社会在各个行业、领域都有非常强的信任体系：商业、教育、金融、房地产、零售等等。这些都是社会高效率运转、人均GDP高的基石，而不是靠人工、加班带来的高效率。当然也有很多问题，比如Vodafone的客服电话要听一个小时音乐才有人接、快递上门不打电话、不死人的急诊要等几个小时、医生经验奇差……。移民之心不死，也想给自己和孩子将来多一个选择，12年到了德国就四处了解长居政策，也让老婆早早学了德语做了储备。到了16年中，在德国居住了四个年头了，不知道是自己老了，还是什么原因，发现居然挺喜欢这种超级简单、单调的生活。对小朋友来说，学业不是一般的轻松，生活压力也小一些，就开始办绿卡，好在准备充分，很快就搞定了。 这段时间的考评及财务状况：考评与年终奖，12年换部门，自然而然地迎来了在华为的第二个年度B考评（预计第三个B或者C在路上了：17年离职），年终奖好像只有不到六万，之后就是三个B+和一个A，赶上公司发钱多，年终奖六万一路涨到六十多（含项目奖）；工资呢，不到12K来到一线，一年后加1K，14年加了2.5K，15年工作确实忙些，成绩也突出，拿到了A考评及地区部优秀个人，遇到了好领导，公司也突击发钱，种种因素综合在一起，两年加了13K最终定格在28K。。。股票和TUP很少，只加了七八万。由于12年高杠杆买房，还啊还啊，好像是直到14年中才缓过来。那两年由于在国外，茶叶生意没做了、借钱买卖也没有了，银行信用贷款也没有了，心理一直不太舒服，感觉又陷入了单纯死工资收入的不安（虽然这些外快其实也没有赚很多钱）。 2014年930新政平地一声雷，给了房地产行业巨大的信心，深圳的房产开始抬头，新闻看了一个月，也无法淡定了，经老婆同意把春华四季园挂牌出售（那会已经很明显红山片区的水榭春天潜力会更大些，值得保留，而且春华房子已经入伙7年了，再不卖恐怕不会再被当做新房买了。个人标准：以深圳的建房质量，一般物业的一手房子，最好能在七八年内卖出，这会卖下家在心理上基本认为还是新房），开始留意关内学区房。兼顾自住需求，最终目标锁定在福田区香蜜湖高级中学片区（个人认为初中学位比小学重要得多）。那会在国外，并没有想过先买后卖，人在国外不能经常回来，信用贷款根本搞不定，同时也只是觉得房价肯定会涨，但是也没看出来会是暴涨。14年底终于有人买了（215万实收），15年初迫不及待回来看房（感谢领导那会正好有个出差机会让我回来一段时间），预算500万，越看越高，大约2月中旬签了香格丽苑640万（114平方）的买卖合同，付了三成，贷款440万，93折利率，30年期。签完回家躺在床上有一种松了一口气的感觉，感觉完成了一件大事（不知道是是因为房地产业的欣欣向荣，还是自己的赌徒心理强，这么多年来，从来没有因为高负债不安、压力大、失眠之类的，只会因为没有把贷款杠杠用到极致而焦虑）。同年330新政出来后，每天担心的事就是卖家反悔，幸运的是并没有发生，同期鼓动老婆回来办了离婚省了十几万的税，每一分钱都是钱啊。关于这次买房，还有一点分享就是，地段重要，附近的刚需也非常重要，这个“刚需”不是说每个人的第一套房，是说这个片区的居住需求。15年初回来看房时顺便看了南山前海和后海，前海还是一片空地，觉得概念早过了，等到兑现则要站岗太久，学位更是没有，pass；后海真是让人眼前一亮，那么多高档办公楼，基本快要是现货了，这得是多少高管要住附近啊，国内的交通成本这么高，时间对高管来说越来越珍贵，附近的房子是真刚需啊，可惜就是学位不行，小孩18年要上学，pass。当时有想过把水榭春天卖掉换深圳湾小房子，但是觉得人在国外操作成本太高、太麻烦，确实也没有预料到17年后海深圳湾在限购高压下还能升值这么多（这些其实都是常驻国外的代价）。这个“地段+刚需接盘侠”理论如果有人觉得有用，那就不枉我这个分享。如果还信地产会暴涨，那就看看前海、宝中以及被前后海双龙戏珠的蛇口片区吧，罗湖、福田、南山，核心产业一路向西是不可逆转的。至于龙华，恩，用来睡觉挺好的；至于坂田、布吉改造，还是再等等吧，不改也不是政治错误，改了也出不了啥成绩，关内还大把地方等着改呢；龙岗中心城，恩，没有产业支撑啊，北站、西丽、前海大片总部、创新基地还嗷嗷待哺呢，产业去中心城，估计也是遥遥无期。 基于德国的超低利率和房价，租金基本可以抵月供（40+年贷款，10年后重新批贷&amp;谈利率），17年初也跟风去买了一个室内114平的新房子，就在公司附近，折合人民币400万+。如果将来有在德国定居，那还好，如果没有，这应该是另外一个愚蠢的投资，德国房价跟中国比起来真是涨的不是一般的慢啊。同期老婆和小姨子各掏了三十万给老丈人在老家买了一个房子，再次进入零存款+月光的日子。 投资及财务部分到此就结束了，除了06年第一次首付，家里赞助的几万块（极其珍贵的几万啊），整个过程靠的是全是银行杠杠和华为工作良好的现金流，可以说两者缺一不可，千言万语化作一句话：不要太高杠杆，也不要太低负债，在自己可控范围内尽量借钱投资，一般人光靠华为的收入在这个社会要翻身几无可能（牛B的将星闪烁者除外）。华为光环带来的高个人信用贷款额度不可浪费，至于下一个十年投资哪里，我是真的不知道，不然也不需要在华为待这么久。 5.华为最后的时光及离开的原因： 在西欧那几年轻松的日子里，其实背后藏着的是对职业前景不明朗的不安，只是这种不安被自己一直认定的“早晚是要离开华为”思想给掩盖了，因此没有去寻求改变、没有去提升自己的技能。本意是想如果能安安稳稳，就在西欧混够八年，也快四十岁了，也该滚了。 可惜变化总是来得比你想象的要快，17年运营商业绩下滑，地区部开始裁员。我也将在10月份满五年必须换一个国家，也换了新领导。我换个国家办工作签证、保留在原部门再待三年的计划不可执行了。要继续留在西欧，就要换部门/国家，而品牌是在地区部德国才有的，就意味着换国家就要换岗位。经过五年的懈怠型工作及自己回顾过去五年错失的中国投资机会，有点想回国折腾下，要是干得爽就留下好好干，不爽就立刻走人，也找到了接收部门。这个时候预备队政策到一线真正执行起来了，地区部也有送人近预备队的指标，新领导希望我能去。前面找的接收部门还是干品牌，要去还得近资源池（因为地区部肯定不会放我去，要我去顶预备队的名额），觉得有点鸡肋。这多种因素加起来，就答应去预备队了，觉得去这个新的品牌部门，基本确定是不会有惊喜的，舒适度肯定不如西欧，去预备队还是未知的世界，会好玩些，反正离职都不怕了，还有什么好怕的呢。 回国后未经任何培训，9月份就去了一个国内炙手可热、组织膨胀超快速的部门作战，可惜还是做Marketing、做品牌。这几个月作战经历加速了、也确定了我该离职，不是说混不下去，也不是这个作战部门有什么不好，而是到了这个部门一段时间后，发现自己的一个致命问题：看着身边不同经历、不同风格的60后、70后、80后、90后同事都在很努力地上演着加班、学习、抢功、甩锅、表现自己、给别人设套、拍领导马屁等等华为基本功力求上进时，我竟然是看在心里忘在脑后，完全不想去参与了，就是说我不止没办法逼自己全心全意投入华为工作，连虚假应付的自制力都没有了。这个在华为是致命的，不可能会开心的，而且36岁了，不管是跳槽还是创业，再不出去尝试下，过几年真的还有力气出去吗，会不会变成现在身边大把担心被华为辞退的老员工之一呢？死就死了，出去试试吧！这个应该是我离开华为最真实的原因，有点类似电视剧里夫妻间的感情已经死了，有没有：） 离职节奏是作战一个月之后，我就确定不想留在中国区了，两个月后，我基本确定要离开华为了：几个老领导、老同事知道我回来了在预备队非常nice的邀请我加入他们所在的各种新部门（也缺人），聊了一下清一色地告知机关的加班风气跟五年前相比是更甚了，不是改善了。在未来经营困难的两年间可想而知会是什么状态了：在华为，销售业绩高增长时代，你好我好大家好，业绩不好了，各个领导都是必须要折腾团队到极限来显示我们已经尽力了已保住乌纱帽，这个是管理者生存基本法则。综合种种因素，还是想走了，至于是长期待在德国，还是中国，慢慢想吧，还有半年女儿才上一年级。 要离开自然就要做些准备，最起码的就是要把银行信用贷款全搞下来，没有华为工作，估计10万都贷不下来。要想贷到最大额的信用贷款，要有一定的计划性，在这里分享，现在信用贷款分两类（不保证百分百准确）： •一类是人工审批，批时给你一个固定额度和期限，期间不会再看你的征信，只是在批时看，放款后上征信； •一类是在网银/手机银行上实时申请，系统自动根据你在人行的实时征信、社保、负债等信息批一个额度给你放款，同样是放款后上征信； 这样的话，如果你要同时在几家银行贷最大额贷款，一定要确保所有的银行在查你的人行征信的那个瞬间是尽量无信用贷款负债（房贷你藏不了）的。尽量集中时间查询征信，集中时间放款，这样才能拿到每家银行最大值的额度，放款后就算被发现负债过高，他们也收不回去了。华为工作几年的人这样操作一般都可以拿到150万+的信用贷款。","categories":[{"name":"article","slug":"article","permalink":"http://lmwtuedu.cn/categories/article/"}],"tags":[{"name":"news","slug":"news","permalink":"http://lmwtuedu.cn/tags/news/"},{"name":"house","slug":"house","permalink":"http://lmwtuedu.cn/tags/house/"}],"author":"樱桃大房子"},{"title":"每个人都逃不掉的消费陷阱","slug":"2018-02-24-每个人都逃不掉的消费陷阱","date":"2018-02-23T16:00:00.000Z","updated":"2019-09-17T08:12:04.639Z","comments":true,"path":"2018/02/24/2018-02-24-每个人都逃不掉的消费陷阱/","link":"","permalink":"http://lmwtuedu.cn/2018/02/24/2018-02-24-每个人都逃不掉的消费陷阱/","excerpt":"","text":"世界就是这样， 好马配好鞍，好船配好帆，王八对绿豆，傻X配脑瘫，没有太大意外，万物都会自然归位。 每个人都逃不掉的消费陷阱 农历狗年春节来临，返乡或出游的人们开启了“买买买”模式。根据银联的报告，去年春节从除夕到正月初五期间，中国人光是银联刷卡就消费了3787亿元。在消费升级的大环境下，预计2018年春节期间的消费将继续保持10%以上的增长态势，而整个2018年，社会消费品零售总额或将突破40万亿元人民币。 不过，当你在愉快地“买买买”的同时是否有思考过，自己是否真的需要自己花钱买的每一件商品？如果答案为否，那么，购物的意义又何在呢？你的每一次不经意的购物，是不是也在不知不觉之中让自己掉入了一个看不见的消费陷阱？ 实际上，现在潜伏在我们每个人面前的，确实有一个看不见的消费陷阱。在不知不觉间，很多人不幸掉落进这个陷阱之中。而讽刺的是，我们设置这个陷阱的原因，恰恰是以“经济发展”为不可辩驳的理由。 一、挤泡沫、打房价，最终还是为了拉动消费 进入2018年，除了消费的预期普遍增高，还有另一个数据也引人注意，那就是房贷的利率进一步上升。 据统计，去年四季度房贷利率平均5.26%，已经持续近一年的上升趋势，而在2018年1月，全国首套房的平均利率已经上升到5.43%，相当于基准利率1.11.倍，比上月上升0.93%。 从房贷利率从去年持续至今的不断上调，可以看到有关部门抑制房价泡沫的意愿。整个2018年，去资产泡沫的大方向应该也不会停下来。 在房地产泡沫被不断抑制的同时，我们发现消费在经济中占比的作用越来越大。据统计局数据，去年，中国经济的总增长中有58.8%都是由消费贡献。官方对于经济增长的宏观叙述，也由传统的“投资拉动”改为“消费和投资共同拉动”。 这个叙述方式的细微改变，反映出了经济部门思路的转变，这对于我们每个人的生活都会产生很大的影响。 在房价泡沫因为低利率而高涨的日子里，普通人年均工资买不了几平米的楼房，尤其一线城市的资产泡沫膨胀，造成了巨大的生活成本压力，使得普通人为了储钱买房而长期不愿消费、不敢消费。 因此，如果要充分释放普通人的消费能力，首先必须让房价不再像过去那样疯长。这样，人们才有可能存的下更多的钱用于消费。 此外，在稳住房价的同时，还得让那些买不起房的人们打消“储钱买房”的长期打算，愿意把手里的钱花出去。这就需要建立长期的公共住房制度。 我们看到，最近召开的经济工作会议，再次强调了尽快建设“多主体供应、多渠道保障、租购并举的住房制度”，也就是所谓的住房长效机制。传媒接二连三的强调住房长效机制建设，可见解决这个问题对于国家来讲有多么的急迫。 这有几分模仿新加坡的住房制度。在“新加坡模式”的住房制度下，昂贵的商品房是专属富人之间的买卖，而中下收入者普遍住进了福利性住房和政府提供的公共住房。这些房子不会给住户产权，但却可以长期赋予其居住使用权。 这样做的最大作用，就是用提供住廉价房的方法，让占据社会大多数的中下层人士能够安心的工作，踏实的消费，为经济增长作出贡献。 俗话说，“民无恒产，则无恒心”，但大部分人一辈子其实也积累不下什么价值昂贵的“恒产”，试问他们怎么可能安心消费？在无法改变大部分人没有“恒产”的情况下，用各种办法给予他们基本安全感，然后引导他们花钱消费，就成为了实现经济增长的重要方法。 在中国经济的巨大存量中，房地产在过去占据了大部分的比例，两年前，地产总价值已占GDP的411%，远远超过国际水准。现在，要想把过度依靠地产的经济转变为“消费拉动型”经济，就必需要以各种手段从房地产中挤出一部分资金，让其流到消费领域。 住房的长效机制和各种抑制不动产泡沫的手段，都是为消费增长做铺垫的手段之一。 不过，仅仅如此依然没办法大幅提高消费。原因在于，中国的流动性依然很紧，人们的收入增长依然不够多。 目前的中国，逐渐进入了一个“缺钱”的状态，虽然最新的数据显示中国的信贷创下新高，但是，流通中货币余额只有7.46万亿元，同比下降13.8%。人民币的货币流通性其实是在下降，人们手里真正能用来交换的钱其实依然很紧，与此同时，中国的居民收入增长水平似乎还撑不起一个庞大的“消费型经济”。 众所周知，这些年来中国人均收入有明显的增长，2017年城镇居民人均可支配收入36396元，比起08年金融危机时的15781元，增长幅度很大。 但如果横向比较，就会发现差距。中国的居民人均可支配收入水平相当于同期美国水平的约12%、日本水平的26%、韩国水平的35%、英国水平的17%，大约等同于美国上世纪70年代初的水平。 如此低下的收入水平，仅仅靠从住房端“减负”显然不足以改变经济增长的模式。 二、透支自己未来的人，将掉进消费的陷阱 进一步促进人们消费的直接方式在于：增加负债。 道理很简单：如果现在的钱不够消费，那就透支未来的钱提前消费，以后慢慢还。人们从货币购买力的不断贬值的事实中学到一课：时间越往后，钱越不值钱。因此，欠钱的时间越长，随着货币贬值，还债压力就会持续减小。既如此，不欠白不欠啊。 于是我们看到，中国人对负债的态度这些年发生了180度的大转变，从贷款买房买车，到贷款上学与日常消费，按揭付款越来越流行。 长期这么下来，老百姓欠下了多少债呢？根据社科院《三季度中国去杠杆进程报告》的数据，居民部门杠杆率延续着上升趋势，2017年前三个季度上升了3.8个百分点，居民的负债与可支配收入之比达到了48.6%。 这个比例甚至远远高于城镇居民储蓄占可支配收入的比例。也就是说，中国人爱存钱的习惯，正在逐渐被爱欠钱的习惯代替。 负债的数字当中，其实有超过一半的部分是被房贷占据了。不过，这个趋势未来很可能会发生改变，随着年青一代住房刚需的逐渐减弱，以及上文所说的“住房长效机制”的建立，以后在这个统计当中，纯消费的比例会不断提高，房贷的部分会慢慢减少。 最终，我们会欠钱购买越来越多不必要的商品，成为消费的奴隶。这并不是危言耸听，那些被裸照逼债的女大学生，还不起钱自杀的年轻人……所有看似个别的现象，其实都是“消费转型”的总体趋势下必然会发生的事情。 你是否发现了一个悲催的现实：老百姓欠债的事实一直没变，改变的是债务类别。从过去长期的房贷欠债变成了未来的消费品债务。随着债务类型的改变，所谓的经济增长模式也相应的发生了改变。但实际上，欠下巨款、吭哧搬砖还钱的从来都是同一拨人。 这一拨人，被消费两个字坑得不轻。 从买房买车，到买各种奢侈品，在社会功能上，“买买买”有一个巨大的作用，那就是以消费品来区分社会阶级。中国人根深蒂固的概念是：用房、车、包、表、衣的品牌来评价一个人的社会阶层。于是，人们玩命的购买象征着“上流阶层”的商品，无以复加的来包装自己，攀比成风、享受成风，最后的结果就是债务成山。 然而，消费其实并不能实际上改变人的阶层，消费实际的作用，无非是产生了市场交换、推动GDP增长。也就是说，消费行为成为了推动经济向前发展的“燃料”。 这有点像韩国电影《雪国列车》的情节设置。在雪原上奔驰的列车里，不同的乘客按照阶层坐在不同车厢，高级阶层坐在列车前端的豪华车厢，低阶阶层坐在列车末尾简陋的硬座车厢。 在硬座车厢的人，无论怎么努力、花多少钱疏通关系，都无法挤进前面的优等车厢。那么这些硬座乘客有什么用呢？他们的“作用”就在于为这列火车提供燃料。 当你花掉你手里的钱，就像是为火车燃烧的锅炉里添加了一铲煤，为火车提速，这其实就是在为经济做贡献。但是，这一笔“经济燃料”燃烧后产生的“废料”却需要你自己承担，那“废料”就是债务，需要你亲手偿还。 这就是消费者最可悲的地方。 政治学家拉斯基曾说过：“消费者几乎不采取行动来控制他们的环境……他们不表达自己的需求，只是等着商家来发现自己的需求，并且商家也只是在能盈利时才会来满足这些需求。” 这段话精辟地总结出了消费者长期被操控、被商家剪羊毛的特性。硬座车厢里的乘客，其实就是负债最多的消费者。 当经济发展已正式转变为“消费拉动”时，广大的消费者是时候长点心了。请在买买买的冲动爆发之前，先想清楚几件事：第一，我买的东西是否是我生活必须的；第二，我是否能在消费后依然保持不欠债的财务原则；第三，每一笔花出去的钱，如果视为投入，那么回报是什么？ 你只有按照这个思路持续玩下去，才有可能在经济的游戏中避免陷入消费的陷阱。否则，等待你的命运就是成为火车锅炉里的那块烧红的煤炭，燃烧自己照亮别人，成为经济机器运转的炮灰。","categories":[{"name":"article","slug":"article","permalink":"http://lmwtuedu.cn/categories/article/"}],"tags":[{"name":"news","slug":"news","permalink":"http://lmwtuedu.cn/tags/news/"}],"author":"孙骁骥"},{"title":"越调控越上涨，楼市将出现报复性反弹？","slug":"2018-02-24-越调控越上涨，楼市将出现报复性反弹","date":"2018-02-23T16:00:00.000Z","updated":"2019-09-17T08:11:56.912Z","comments":true,"path":"2018/02/24/2018-02-24-越调控越上涨，楼市将出现报复性反弹/","link":"","permalink":"http://lmwtuedu.cn/2018/02/24/2018-02-24-越调控越上涨，楼市将出现报复性反弹/","excerpt":"","text":"越调控越上涨，楼市将出现报复性反弹？ 中国的楼市调控已经进入了新一轮的“松绑期”，不过，这一次是以一种悄无声息的方式在进行。 前段时间，兰州、合肥、南京等部分城市尝试有限度的“松绑限购”，但很快又出来辟谣：楼市调控政策不会变，“松绑”的传闻纯属想多了。尽管各地对外都宣称“限购政策不会松绑”，但我们依然感到全国楼市开始呈现出一种报复性的反弹。 数据也显示出目前新的楼市反弹趋势：一线核心城市微幅涨价，但成交量依然很低；二三四线城市则是量价齐涨，幅度比一线来得大。这个新趋势，值得我们进一步思考。 一、房企杀向中西部，楼市“二元格局”形成 如今，楼市调控的声音喊得比什么时候都响，但调控的结局却仍然和历次调控一样：越调越涨。 目前楼市反弹究竟有多少？不妨来看看最近的楼市数据： 2018年1月，核心城市的房价慢慢开始回暖，涨价不声不响的开始。根据某房屋交易网站数据，北京上月的二手房成交量环比增长2.9%，均价涨幅0.3%。上海上月的二手房均价上涨超过2%，深圳的二手均价上涨超过1.5%，同时，成交量也略有增加。 就全国范围来看：自2017年第四季度开始，二手住宅市场便已经处于量价小幅趋减的态势，而到了2018年首月，二手市场开始逐渐回暖，成交量已回归到2017年第三季度末的水平，价格略有上调。“楼市回暖”这几个字，成为了不少城市在今年一月份的关键词。 不过，短期的价格和成交量的数据还看不出大趋势所在。要想对楼市有一个更宏观的把握，需要再看看过去一年的走势。 根据统计局数据，2017年全年，中国商品房销售额平均增长12.7%。如果分区域来看，中西部地区成为了市场增量最集中的地方。 数据显示，中部地区和西部地区商品房销售分别增长了22.5%和25.6%，远远高于东部地区的5.3%。就连经济普遍不看好的东北地区，销售也同比增长22%。 但同时，西部和东北这两个经济相对落后的地区，地产开发的资本投入是全国偏低的，商品房销售额在这些欠发达的地方却呈现高速增长。两者的差异，恰恰预示着泡沫正在逐渐显现。 不过，对于房价已经涨得非常高的一线城市来说，量价增幅缓慢的楼市呈现出一种较稳定的刚性泡沫。反倒是三四线城市，量价齐升的楼市，似乎大幅超过了当地居民的实际收入增幅。因此，在这些地方，楼市投机泡沫的味道就要更重一些，风险和不可预测性都更强。 简言之，一二线的楼市泡沫刚性化，三四线以下楼市泡沫投机化，中国楼市已呈现“二元化格局”。 造成中国楼市“二元化”的原因又是什么呢？这就需要了解下近期房企的动向。 根据国家统计局数据，去年中国的整体房地产开发投资量出现了下降减速的迹象，尤其是在4月以后，地产投资增速从9.3%逐步下降，到年底降到7.5%左右。 但与此同时，房地产开发企业土地购置面积却在不断增大，达到22158万平方米，同比增长从年初的6.2%来到年末的16.3%，土地成交价款11436亿元，增长47.0%，增速提高3.7%。 可见，总体而言，资金流入地产的速度在变慢，但是房企拿地的速度和面积却在增大。两者的变化呈现“背离”的趋势。即是说在过去的一年，资金和土地的增速“一慢一快”。 在这“一慢一快”之间，说明目前房企都纷纷跑到地价更为便宜的非核心城市拿地。这些非核心城市，往往集中在缺乏强大经济支撑的中西部地区，虽然开发成本比较低廉，但支撑房价的资本硬度也不足。房企的商业开发链条，在不断将新楼盘带到这些地区的同时，也带来了风险。 二、地产之毒不断在“调控—反弹”的怪圈中循环 据CREIS中指数据，2017年热点一二线城市在严厉的政策调控下成交规模明显缩减，部分二线及三四线城市出现了发展契机。前50的房企对二线及三四线城市业绩贡献占比分别为61.2%和18.2%，较上一年度增长5.4%和1%，一线城市则下降6.3%。 全国土地出让的数据显示，去年，300城市土地出让金收入总额为40123亿元，同比增加36%，增量主要集中在中西部地区。在限制房产业发展的背景下，土地出让金依然增长如此之快，也从另一侧面体现出房企们“进军中西部”的声势多么浩大。 在年销售额数千亿级别的超大型房企涌入中西部拿地开发的同时，我们还注意到，大量五百到一千亿之间的“中量级企业”进入中西部城市拿地开发。 这一档次的典型房企，例如中南置地，新拿的地块就主要集中于成都、西安、武汉、昆明等中西部地区；正荣集团则是布局西安、合肥、武汉、长沙等等城市；金科主要集中布局在西部城市…… 数量众多的中型房企加上龙头房企如碧桂园、恒大、融创等“巨无霸”大举进入中西部，造成了去年以来中西部地区遍地工地、大搞“地产大开发”的局面。 但是，圈了一大片土地的房企，最后却发现房子貌似卖不动了。统计局数据显示，全国商品房的销售面积和销售额的平均增速，从2016年末的22.5%和34.8%，骤然下降到2017年底的7.9%和12.7%。总体而言，卖房子这件事现在变得越来越难。 房地产大开发的结果必然是库存上升，去库存的周期变长。虽然2017年三四五线城市售楼增长同比上升14.3%，然而比起房企的疯狂的拿地开发，这点销量依然不成比例，并不能短期消化新增的库存。在某些中西部城市开发的新楼盘，据说还要至少十年才能完全把这些楼房卖出去。 于是，这就带来一个问题：对房企而言，卖不掉房意味着之前拿地开发投资的回款周期变长，时间一长，各种不确定的风险因素就会增加。这对于与房企深度利益绑定的国有银行来说，也是一个很不安的讯号。 金融与地产的利益同构，风险当然也同构，而依赖土地出让的地方政府此时只能选择帮助银行，至少不能让其陷入地产滞销带来的金融风险之中。 地方这样做的动机有多强呢？我们来看一下各城市对于土地出让利益的依赖度。据统计，中国各地土地出让金占公共财政预算收入的比例相当高。有不少主要城市都在20%到30%左右，成都、合肥、济南等地超过43%，而像是杭州、南京、佛山等地更是高达50%以上。房地产依然是地方的主要财源。 对地方经济而言，救房企就等于救银行，也就等于救了地方的财源。因此，不管媒体表面上如何强调限购管控，但每个城市都深知，只有确保房价不跌、销量可持续增长，地产商才会有持续开发的意愿，如此，地方未来的财源才会有保障。 这也正是现在某些地方开始采用灵活的限购标准、有限度松绑楼市的原因。由于开发商、银行和地方政府的既定关系并没有被打破，我们也将会在越来越多的非一线城市看到楼市的“回暖”。 从这个角度来观察，楼市调控的本质，已被看透。 其实，所谓的调控就好像是瘾君子被强制戒毒，但由于身体太虚弱，如果彻底断毒，恐怕扛不住，因此，每当戒毒一段时间，又必须要悄悄再吸一点毒，否则就很容易毒瘾发作身亡。 也就是说，中国经济要想戒“房地产”的毒，但又不敢用力过猛，只能是边戒边吸，反复折腾。 什么房地产的周期，其实就是地产毒瘾从发作到戒毒再到复发的循环周期。地产之毒不断在“戒毒—复吸”的怪圈中循环，全民跟着受罪。在这个循环往复的过程中，只要调控的强制手段稍微松懈，反弹的力度就会异常强烈。 如今，地产大佬们大举杀向新开辟的土地市场，说明他们依然是在利用中国经济依赖地产的惯性来做生意。实质上，地产业也是在捞传统“地产金融”的最后一桶金，同时为下一步的资本转型做准备。在中国的土地红利被彻底榨干净以前，房企主导的这种“资本大洗牌”并不会停止。","categories":[{"name":"article","slug":"article","permalink":"http://lmwtuedu.cn/categories/article/"}],"tags":[{"name":"news","slug":"news","permalink":"http://lmwtuedu.cn/tags/news/"}],"author":"孙骁骥"},{"title":"多语言实现方案","slug":"2018-02-05-多语言实现","date":"2018-02-05T16:00:00.000Z","updated":"2019-09-17T08:09:57.217Z","comments":true,"path":"2018/02/06/2018-02-05-多语言实现/","link":"","permalink":"http://lmwtuedu.cn/2018/02/06/2018-02-05-多语言实现/","excerpt":"","text":"前言开发过程中，不知道你的客户是否有海外用户呢？ 如果没有，那么恭喜你，出门右拐；不送！ 好了，废话不多说，上干货； 内容不是我写的，我只是一个搬运工，整理归纳输出： 内容标签：SpringMVC velocity 不要问我：为什么不是 JSP视图解析器 FreeMarker视图解析器 而是 Velocity视图解析器 ； 因为我写的代码框架就是用的Velocity；如果需要其它框架，请自行百度，或者出门右拐，不送！ 闲暇时，我也会整理一些其它框架内容， 如果时间允许，后续补充…。 正题我们常常看别人的开源代码或者其他工程时候，是不是有时会瞟见这样的一个词 I18N; 如果你没见到，没关系，现在你就知道了； “I18N 作为国际化的简称， 其来源时英文单词 internationalization的首末字符的i和n，18为中的字符个数”。 转载内容Spring MVC + Velocity实现国际化配置 Spring国际化配置主要3个关键点： ResourceBundleMessageSource： 实现国际化资源的定义 LocaleResolve: 实现本地化信息的解析 LocaleChangeInterceptor： 实现本地化信息的监听（来实现url参数动态指定locale）。 LocaleResolver LocaleResolver 是指用什么策略来检测请求是哪一种locale,Spring MVC提供了以下几种策略： AcceptHeaderLocaleResolver 根据浏览器的 http header 中的 accept-language 域判定浏览器的语言环境， 可以通过httpServletRequest.getLocale获取域的内容，但是无法调试localeResolver接口的setLocale设置locale设置locale， 基于这个策略，在后面的demon中； 可以实现基于浏览器的国际化案例。 SessionLocaleResolver 根据用户本次会话过程中的语言设定决定语言种类， session级别的，在此sessio周期内可以修改语言种类，但是session失效后，语言设定失效， 基于这个策略，在后面的demon中可以实现基于session的国际化案例。 CookiedLocaleResolver 根据Cookie判定用于的语言设定（Cookie保存着用户前一次的语言设定参数)。 FixedLocaleResolver 一直使用固定的Locale,改变locale是不支持的。如果需要使用哪一种策略，只需要在DispatcherServlet 制定的Spring配置文件中配置就行，DispatchServlet将在初始化的时候调用initLcaleResolver(context)方法区配置文件中找名字为localeResolver的bean， 如果有就使用配置文件的。没有就使用默认的 AcceptHeaderLocaleResolver 。 基于浏览器请求的国际化使用AcceptHeaderLocaleResolver策略实现基于浏览器语言的国际化。 首先配置国际化的资源文件 定义国际化资源文件内容，后缀为.properties; 注意编写的名称信息 ⚠️注意：中文编码采取unicode 配置本地化信息解析策略，这里是基于浏览器的为默认配置，因此可以不做配置。 最后前段界面通过使用spring针对不同view视图提供的标记处理国际化信息， velocity标记如下： 运行测试效果程序，显示不同效果需要将 浏览器的语言更换，例如简体中文，英文（美国） 基于浏览器的国际化配置就搞定了，由于是根据浏览器的语言环境来解析的，配置十分的简单； 可是搞了大半天我们只是解决了前端一些特定（固定）数据的多语言； 但是交互的数据，后端如何解决国际化呢？ 如果只是一些简单的数据，例如提示错误信息等等，也可以通过配置文件解决。 数据库的国际化问题，是另外一个层面东西；一般很少考虑用户输入的东西是不是国际化。 基于Session的国际化实现基于Session的国际化配置比基于浏览器的略复杂，在其基础上，需要经过如下配置。 编写一个action行为，去更改语言（此方法与你手动更改浏览器的效果一样，差不多； 但是这个部分设置可以让你后台数据传输的时候，检查当前的语言环境，通过session获取语言） 编写配置文件 运行测试与之前编写的浏览器的方式一样，只是更改语言的方式，换成了发送请求，可以用POST请求方法区更改语言； 我为了测试方便，写成了GET请求方法。 到此为止，基于session的国际化配置完结，基于session 的国际化是相对基于浏览器语言来说比较常用的一种方式。 缺点： session会话结束时，设置的语言环境就被删除了。 基于Cookie的国际化实现大多数情况下，国际化都是基于Cookie的， 用户在设置完一次语言信息之后，之后自己没有修改，就算退出再登录，语言也是之前设置的，除非用户自己手动情况，这种要通过Cookie来实现了。 配置国际化资源文件（参考基于浏览器国际化配置） 配置本地话信息解析策略，这里将基于session的该配置项替换成为如下即可： 结束语 谁的职场都会忙碌辛苦，免不了有加班熬夜，但一定要先让自己成为一个内心幸福的人，才会在一天的埋头十多个小时之后依然觉得满足而充满希望。","categories":[{"name":"code","slug":"code","permalink":"http://lmwtuedu.cn/categories/code/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://lmwtuedu.cn/tags/SpringMVC/"},{"name":"velocity","slug":"velocity","permalink":"http://lmwtuedu.cn/tags/velocity/"}],"author":"LJ"},{"title":"Java 栈和堆","slug":"2018-02-02-Java 栈和堆","date":"2018-02-01T16:00:00.000Z","updated":"2019-09-17T08:09:06.666Z","comments":true,"path":"2018/02/02/2018-02-02-Java 栈和堆/","link":"","permalink":"http://lmwtuedu.cn/2018/02/02/2018-02-02-Java 栈和堆/","excerpt":"","text":"Java 栈和堆堆区： 存储的全部是对象，每个对象都包含一个与之对应的class信息（class的目的是为了得到操作指令）。 JVM 只有一个堆区（HEAP）被所有线程共享，堆中不存放基本类型和对象引用，只放对象本身栈区。 栈区： 每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用（不是对象），对象都存放在堆区中。 每个栈中的数据（原始类型和对象引用）都是私有的，其它栈不能访问。 栈分为3部分： 基础类型变量区、执行环境上下文、操作指令区（存放操作指令）。 方法区： 又叫静态区，跟堆一样，被所有的线程共享。 方法区包含所有的class和static变量. 方法区中包含的都是在整个程序中永远唯一的元素，如class, static变量。 数据内在的分配程序运行时，我们最好堆数据保存到什么地方做到心中有数；有6个地方都可以保存数据： 寄存器 这是最快的保存区域，因为它位于和其它所保存的方式不同的地方——处理器内部。然而，寄存器的数量十分有限，所以寄存器时根据需要由编译器分配。 我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。 堆栈 驻留常规RAM（随机访问存储器）区域。但可通过它的“堆栈指针”获得处理的支持。堆栈指针若向下移，会创建新的内存； 若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时， Java编译器必须准确的知道堆栈内保存的所有数据的“长度”以及“存在时间”。 这是由于它必须生成相应的代码。以便向上和向下移动指针。这一限制无疑影响了程序的灵活性，所以尽管有些java数据要保存在堆栈里——特别是对象具柄，但是Java对象不放到其中。 堆 一种常规用途的内存池（也在RAM区域），其中保存了Java对象。和堆栈不同——“内存堆”或“堆”最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长时间。因此用堆保存数据时会得到更大的灵活性。 要求创建一个对象时，只需要用new命令编制相应的代码即可。 执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价： 在堆里分配存储空间时会花费掉更长的时间。 静态存储 这儿的“静态”是指“位于固定位置”。 程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但Java对象本身永远都不会置入静态存储空间。 常数存储 常数值通常直接置于程序代码内部。 这样做是安全的， 因为它们永远都不会改变，有的常数需要严格的保护，所以考虑将它们置入只读存储器（ROM）。 非RAM存储 若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的可控范围之外。其中两个最主要的例子便是 “流式对象”和“固定对象”。 对于流式对象，对象会变成字节流，通常会发给另一台机器，而对于固定对象，对象保存在磁盘。 即使程序终止运行，它们仍可保持自己的状态不变。 对于这些类型的数据存储，一个特别有用的技艺就是它们能存在于其他媒体中， 一旦需要，甚至能将它们恢复成普通的、基于RAM的对象。 转载 :http://bbs.csdn.net/topics/370001490 转载：https://www.cnblogs.com/yanduanduan/p/7150874.html","categories":[{"name":"code","slug":"code","permalink":"http://lmwtuedu.cn/categories/code/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://lmwtuedu.cn/tags/Java/"},{"name":"栈和堆","slug":"栈和堆","permalink":"http://lmwtuedu.cn/tags/栈和堆/"}],"author":"LJ"},{"title":"深圳-周游记","slug":"2018-01-26-周游记","date":"2018-01-25T16:00:00.000Z","updated":"2019-09-17T08:08:40.824Z","comments":true,"path":"2018/01/26/2018-01-26-周游记/","link":"","permalink":"http://lmwtuedu.cn/2018/01/26/2018-01-26-周游记/","excerpt":"","text":"周游记 语录： 愿你在被打击时，记起你的珍贵，抵抗恶意； 在迷茫时，坚信你的珍贵。 爱你所爱，行你所行，听从你心❤️，无问西东 —–《无问西东》 我喜欢独自一个带着相机，游走在大街上，像一个孤独的行者；无所目的，任意游走在道路上；我享受这份孤独带给我心灵的慰藉！ 我也害怕寂寞，它会召醒我大脑内心深处的记忆，深夜我会记起曾经的旧友，也会记起曾经恋人的青涩的回忆… 竹子林地铁站 手印 青涩的女孩 东门 小梅沙 沙头角 远兮: 人生有许多个十年，你还有多少个十年呢？","categories":[{"name":"life","slug":"life","permalink":"http://lmwtuedu.cn/categories/life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"http://lmwtuedu.cn/tags/Life/"},{"name":"Travel","slug":"Travel","permalink":"http://lmwtuedu.cn/tags/Travel/"}],"author":"LJ"},{"title":"聊聊WEB数据提交方式-POST","slug":"2018-01-23-聊聊WEB数据提交方式","date":"2018-01-22T16:00:00.000Z","updated":"2019-09-17T08:08:19.713Z","comments":true,"path":"2018/01/23/2018-01-23-聊聊WEB数据提交方式/","link":"","permalink":"http://lmwtuedu.cn/2018/01/23/2018-01-23-聊聊WEB数据提交方式/","excerpt":"","text":"聊聊WEB数据提交方式-POST知识点摘录(网络转载)大家都知道HTTP1.1规定了HTTP的请求方法：OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 。 POST就是向服务端提交数据的。 我们知道，HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样： 1234&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们。 application/x-www-form-urlencoded 这应该是最常见的 POST 提交数据的方式了。浏览器的原生 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）： 1234POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。例如 PHP 中，$_POST[‘title’] 可以获取到 title 的值，$_POST[‘sub’] 可以得到 sub 数组。 很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。 multipart/form-data 这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 表单的 enctype 等于 multipart/form-data。直接来看一个请求示例： 12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=\"text\"title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=\"file\"; filename=\"chrome.png\"Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。关于 multipart/form-data 的详细定义，请前往 rfc1867 查看。 这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 表单也只支持这两种方式（通过 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。 随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。 pplication/jsonapplication/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。 JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。 Google 的 AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码： 1234var data = &#123;&apos;title&apos;:&apos;test&apos;, &apos;sub&apos; : [1,2,3]&#125;;$http.post(url, data).success(function(result) &#123; ...&#125;); 最终发送的请求是： 1234POST http://www.example.com HTTP/1.1 Content-Type: application/json;charset=utf-8&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125; 这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。一些 php 框架已经开始这么做了。 text/xml我的博客之前提到过 XML-RPC（XML Remote Procedure Call）。它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的： HTMLPOST http://www.example.com HTTP/1.1Content-Type: text/xml examples.getStateName 41 XML-RPC 协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如 WordPress 的 XML-RPC Api，搜索引擎的 ping 服务等等。JavaScript 中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。不过，我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。 本文链接：https://imququ.com/post/four-ways-to-post-data-in-http.html 知识点补充enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。默认地，表单数据会编码为 “application/x-www-form-urlencoded”。就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为 ASCII HEX 值）。 enctype属性值 值 描述 application/x-www-form-urlencoded 在发送前编码所有字符（默认） multipart/form-data 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 text/plain 空格转换为 “+” 加号，但不对特殊字符编码。 场景使用在使用springMVC的时候，前端请求一般使用ajax； ajax里面有一个content-type属性；而这个属性是告诉后端，传递数据的类型是什么。 平常我们前端使用”application/json”和“application/x-www-form-urlencoded” 设置content-type。 而后端我们一般采取”@RequestBody”和”@RequestParam”; 他们区别是什么呢？ “application/x-www-form-urlencoded” &gt;&gt;&gt;&gt;&gt;&gt;&gt; @RequestParam 注解配对 “application/json” &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; @RequestBody 注解配对 疑惑内容转载1234567891011121314151617181920212223242526272829303132**解决疑惑的网址：URL**具体的处理办法就是在我们的ajax请求中headers: &#123;&apos;Content-Type&apos;:&apos;application/x-www-form-urlencoded&apos;&#125;这里还需要做实验进行测试才行。还有一个问题是ajax提交方式和post提交方式有所不同，用jQuery的ajax方法和post方法分别发送请求，在后台Servlet进行处理时结果是不一样的，比如用$.ajax方法发送请求时（data参数是一个JSON.stringify()处理后的字符串，而不是一个JSON对象）但此时是不可用request.getParam(key) 来取值的。如果用$.post方法来发送请求（data参数是一个JSON对象,而不要再用JSON.stringify()处理为字符串了），结果恰恰相反。@RequestParamA） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String--&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；B）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；C) 该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定；@RequestBody该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api; 参考 参考内容：SpringMVC数据传输的过程 参考内容： 四种常见的 POST 提交数据方式 专题","categories":[{"name":"code","slug":"code","permalink":"http://lmwtuedu.cn/categories/code/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://lmwtuedu.cn/tags/HTTP/"},{"name":"POST","slug":"POST","permalink":"http://lmwtuedu.cn/tags/POST/"}],"author":"LJ"},{"title":"Jekyll Liquid API 文档","slug":"2018-01-22-Jekyll-Liquid-API-语法文档","date":"2018-01-21T16:00:00.000Z","updated":"2019-09-17T08:05:02.719Z","comments":true,"path":"2018/01/22/2018-01-22-Jekyll-Liquid-API-语法文档/","link":"","permalink":"http://lmwtuedu.cn/2018/01/22/2018-01-22-Jekyll-Liquid-API-语法文档/","excerpt":"Jekyll/Liquid API 语法文档转载原文出处：查看原文点击 前言如果你只想快速搭建一个GitHub的静态网站，而暂时没有时间来研究 Jekyll 语法的话，建议直接 Fork 别人的主题源码。 当然，阅读一下之前我记录的一些笔记也可以增长一些知识： 建立 GitHub Pages 静态博客网站 介绍了使用 Jekyll 搭建的 GitHub Pages 操作 GitHub Pages Issue 介绍博主在使用 GitHub Pages 的过程中遇到的问题及解决方法 讲解 Markdown 介绍了标准的 Markdown 语法及相关的扩展语法 现在博主想要整理一份相对完整的Jekyll语法，方便以后查阅参考。 具体官方文档地址请参考 Jekyll Documentation 这里主要介绍关于 Jekyll 的 API 语法，不是翻译官网内容。 开始 _Jekyll is a parsing engine bundled as a ruby gem used to build static websites from dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as &ldquo;a simple, blog aware, static site generator&rdquo;._ Jekyll 是什么？ Jekyll 是一个静态网站生成器。 Jekyll 通过标记语言 markdown 或 textile 和模板引擎 liquid 转换生成网页。 GitHub Pages 后台运行 Jekyll，为我们提供了一个地方贮存管理博客网页，我们可以使用 Jekyll 做一个自己的网站。 这里不介绍如何在本地安装使用 Jekyll，如果想本地使用，请参考官方文档：安装教程和使用教程 不过这里可以透漏一下，Jekyll 依赖于 ruby 开发平台。","text":"Jekyll/Liquid API 语法文档转载原文出处：查看原文点击 前言如果你只想快速搭建一个GitHub的静态网站，而暂时没有时间来研究 Jekyll 语法的话，建议直接 Fork 别人的主题源码。 当然，阅读一下之前我记录的一些笔记也可以增长一些知识： 建立 GitHub Pages 静态博客网站 介绍了使用 Jekyll 搭建的 GitHub Pages 操作 GitHub Pages Issue 介绍博主在使用 GitHub Pages 的过程中遇到的问题及解决方法 讲解 Markdown 介绍了标准的 Markdown 语法及相关的扩展语法 现在博主想要整理一份相对完整的Jekyll语法，方便以后查阅参考。 具体官方文档地址请参考 Jekyll Documentation 这里主要介绍关于 Jekyll 的 API 语法，不是翻译官网内容。 开始 _Jekyll is a parsing engine bundled as a ruby gem used to build static websites from dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as &ldquo;a simple, blog aware, static site generator&rdquo;._ Jekyll 是什么？ Jekyll 是一个静态网站生成器。 Jekyll 通过标记语言 markdown 或 textile 和模板引擎 liquid 转换生成网页。 GitHub Pages 后台运行 Jekyll，为我们提供了一个地方贮存管理博客网页，我们可以使用 Jekyll 做一个自己的网站。 这里不介绍如何在本地安装使用 Jekyll，如果想本地使用，请参考官方文档：安装教程和使用教程 不过这里可以透漏一下，Jekyll 依赖于 ruby 开发平台。 目录结构Jekyll 的标准目录结构如下： 12345678910111213141516.├── _config.yml├── _includes/| ├── footer.html| └── header.html├── _layouts/├── _posts/| ├── 2007-10-29-why-every-programmer-should-play-nethack.md| └── 2014-04-26-what-is-Jekyll.md├── _drafts/| └── begin-with-the-crazy-ideas.md├── _data/| └── members.yml # yaml files(end with &quot;.yml&quot; or &quot;.yaml&amp;)├── _site/└── index.html # http://alfred-sun.github.com/ 顺便提一下，执行 jekyll new SITENAME 可以快速的生成一个基础的 Jekyll site 网站示例。 文件介绍_config.yml Jekyll 的全局配置文件。 比如网站的名字，网站的域名，网站的链接格式等等。 _drafts 未发布的 posts 存放的地方，这里的 post 文件名不需要加日期标记。 _includes 该目录下的文件内容是最终要放进模版文件中的一些代码片段。 对于网站的头部，底部，侧栏等公共部分，为了维护方便，我们可能想提取出来单独编写，然后使用的时候包含进去即可。 这时我们可以把那些公共部分放在这个目录下，使用时只需要引入即可。 1&#123; % include filename % &#125; _layouts 存放的一些模版文件，模版是用来包含并装饰 page 或 post 内容的。Jekyll的模版使用 HTML 语法来写，并包含 YAML Front Matter。 所有的模版都可用Liquid来与网站进行交互，都可以使用全局变量 site 和page 。 site 变量: 包含该网站所有可以接触得到的内容和元数据(meta-data) page 变量: 包含的是当前渲染的page或post的所有可以接触得到的数据 对于网站的布局，一般会写成模板的形式，这样对于写实质性的内容时，比如文章，只需要专心写文章的内容，然后加个标签指定用哪个模板即可。 对于内容，指定模板了模板后,我们可以称内容是模板的儿子。 为什么这样说呢？ 因为这个模板时可以多层嵌套的，内容实际上模板，只不过是叶子节点而已。 在模板中，引入儿子的内容： 1&#123; &#123; content &#125; &#125; 在儿子中，指定父节点模板： 注意，必须在子节点的顶部。 123--- layout: post--- _posts 发布的内容，比如博客文章，常放在这里面，而且一般作为叶子节点。 文件的命名必须遵循：YEAR-MONTH-DAY-title.MARKUP。 另外，所有放在根目录下并且不以下划线开头的文件夹中有格式的文件都会被 Jekyll 处理成 page。 这里说的有格式是指含有 YAML Front Matter 头部的文件。 所有的 post 和 page 都要用 markdown 或者 texile 或者 HTML 语法来写，可以包含 Liquid 模版的语法。而且必须要有 YAML Front Matter 头部( Jekyll 只处理具有 YAML Front Matter 的文件)。 YAML Front Matter 必须放在文件的开头，一对 --- 之间，用户可在这一对 --- 间设置预先定义的变量或用户自己的数据。具体看下面的说明。 _data Jekyll 支持从该目录中加载 YAML、 JSON、 和 CSV 格式（.yml、yaml、json 或 csv 扩展名）的文件数据。用于配置一些全局变量，不过数据比较多，所以放在这里。 比如，多人参与网站开发，我们通常会在这里面定义一个 members.yml 文件。 例如文件内容为： 123456- name: Tom Preston-Werner github: mojombo- name: Parker Moore github: parkr 然后在模板中我们就可以通过 site.data.members (注意：文件名决定变量名)使用这些数据。 123456789&lt;ul&gt;&#123; % for member in site.data.members % &#125; &lt;li&gt; &lt;a href=&quot;https://github.com/&#123; &#123; member.github &#125; &#125; &quot;&gt; &#123; &#123; member.name &#125; &#125; &lt;/a&gt; &lt;/li&gt;&#123; % endfor % &#125; &lt;/ul&gt; _site Jekyll 生成的网页默认输出的地方，一般需要在 .gitignore 中屏蔽掉这个目录。 index.html 主页文件，后缀有时也用 index.md 等。 这个需要根据自己的需要来写，因为不同的格式之间在某些情况下还是有一些细微的差别的。 其他静态资源 对于其他静态资源，可以直接放在根目录或任何其他目录，然后路径和平常的网站一样，按路径来找链接中的文件。 配置全局变量虽然全局变量都有自己的默认配置，但是我们往往会手动配置为自己心中最好的效果。 另外，一些全局变量既可以在配置文件中设置，也可以在命令行选项参数里指定。 注意，配置不用使用 tab，否则可能会忽略那条命令。 源代码的位置这个一般不配置，默认即可。 1source: DIR 当然编译的时候也可以指定，但是使用 github 我们是不能指定参数的。 1-s, --source DIR 输出网站位置这个一般也是默认。 12# 编译参数 -d, --destination DIRdestination: DIR #配置语法 Safe 开关官方文档上就一句话： 1Disable custom plugins, and ignore symbolic links. 大概意思是禁用常用的插件，忽略符号链接。 12# 编译参数 --safe safe: BOOL Base URL将 Jekyll 生成的网站内容放置在域名的子路径下面。 我们经常需要在多个地方运行 Jekyll，如发布到 GitHub Pages 前在本地预览下网站。--baseurl 标记就是为此而生的。 首先在 _config.yml 文件添加 baseurl，然后在网站各个链接的地方加前缀 { { site.baseurl } }。 当 jekyll serve 预览本地网站时，在本地域名后追加 --baseurl 的值（类似 / 这样的路径）。 12# baseurl: &quot;/blog&quot; 编译参数: --baseurl URLbaseurl: URL 注意：所有的 page 和 post 的 URL 都是以斜线 / 领头，那么当 site.baseurl=/ 时，连接的 URL 会出现两个重复的 / 而破坏超链接。因此，建议只在 baseurl 有具体值时才使用 site.baseurl 给 URL 加前缀。 忽略文件这个很有用，有时候你写了一个文件，里面的一个东西可能会被 Jekyll 处理，但是你不想让 Jekyll 处理的话，就使用这个语法忽略那些文件。 1exclude: [DIR, FILE, ...] 强制处理文件有时候我们的一些文件的名字由于不在 Jekyll 处理的文件名字范围内，这时候就需要强制处理这些文件了。比如 .htaccess 文件。 12# include: [&quot;.htaccess&quot;]include: [DIR, FILE, ...] 时区模板中经常会对时间进行转换，这个时候如果至指定时区的话，可能得到的时间会和我们想要的时间错几个小时。在这里能查看到可用的值。 12# timezone: Asia/Shanghaitimezone: TIMEZONE 编码大家都是程序员，就不用多说了。 执行 ruby -e &#39;puts Encoding::list.join(&quot;\\n&quot;)&#39; 可列出本地 Ruby 可用的编码。 12# encoding : utf-8encoding: ENCODING 文章链接格式我们可以自定义 Post 的 URL 格式，通过 permalink 来配置。比如： 12345678# 设定 permalink 取值permalink: /:year/:month/:day/:title.html# 那么 post: 2014-10-19-slap-chop.md 最终输出的路径 URL 变成# /2014/10/19/slap-chop.htmlpermalink: /:month-:day-:year/:title # =&gt; /04-29-2009/slap-chop/index.htmlpermalink: pretty # =&gt; /2009/04/29/slap-chop/index.html 另外，还有3种内置的链接格式可以使用： PERMALINK STYLE URL TEMPLATE date /:categories/:year/:month/:day/:title.html pretty /:categories/:year/:month/:day/:title/ none /:categories/:title.html 分页通常我们都不想把所有的 Post 都放在一页显示，而是要分成多页显示。好在 Jekyll 支持分页显示，通过 paginate 和 paginate_path 两个变量来设置每页显示的数量和分页 HTML 的 URL 路径。 12paginate: 5paginate_path: &quot;blog/page:num/&quot; 根据上面的配置，Jekyll 会读取 blog/index.html 文件，把每页赋值给全局变量 paginator，并输出 HTML 分页文件，如：第2页为 blog/page2/index.html。其中，“page” 是字符常量，变量 :num 是分页的页码，自动从 2 开始编码，因此在罗列所有页面页码及它们的超链接时要注意一下，首页链接没有中间的 “page1” 路径。 通过 paginator 的相关属性我们可以实现在不同页间切换。 1234567891011121314151617181920212223&lt;!-- This loops through the paginated posts --&gt;&#123; % for post in paginator.posts % &#125; &lt;h1&gt;&lt;a href=\"&#123; &#123; post.url &#125; &#125; \"&gt;&#123; &#123; post.title &#125; &#125; &lt;/a&gt;&lt;/h1&gt; &lt;p&gt;&lt;span class=\"date\"&gt;&#123; &#123; post.date &#125; &#125; &lt;/span&gt;&lt;/p&gt; &lt;div class=\"content\"&gt; &#123; &#123; post.content &#125; &#125; &lt;/div&gt;&#123; % endfor % &#125; &lt;!-- Pagination links --&gt;&lt;div class=\"pagination\"&gt; &#123; % if paginator.previous_page % &#125; &lt;a href=\"&#123; &#123; paginator.previous_page_path &#125; &#125; \" class=\"previous\"&gt;Previous&lt;/a&gt; &#123; % else % &#125; &lt;span class=\"previous\"&gt;Previous&lt;/span&gt; &#123; % endif % &#125; &lt;span class=\"page_number \"&gt;Page: &#123; &#123; paginator.page &#125; &#125; of &#123; &#123; paginator.total_pages &#125; &#125; &lt;/span&gt; &#123; % if paginator.next_page % &#125; &lt;a href=\"&#123; &#123; paginator.next_page_path &#125; &#125; \" class=\"next\"&gt;Next&lt;/a&gt; &#123; % else % &#125; &lt;span class=\"next \"&gt;Next&lt;/span&gt; &#123; % endif % &#125; &lt;/div&gt; 默认值设定设置 YAML Front Matter 变量的默认值。 写 post 时，经常需要在每篇文章的 YAML 头部设定一些相同的变量使用，比如：author、layout等。为了避免这些不必要的重复性操作，我们可以在配置文件中设定他们的默认值； 同时在必要的时候，还可以对具体文件设定头部变量，覆盖其默认值。下面很快就会说这点。 1234567891011121314151617# In _config.yml, set the layout and author for files where the type is &quot;posts&quot;.# And any html files that exist in the &quot;projects/&quot; folder will use the &quot;project&quot; layout, if it exists....defaults: - scope: path: &quot;&quot; # an empty string here means all files in the project type: &quot;posts&quot; # previously `post` in Jekyll 2.2. values: layout: &quot;post&quot; author: &quot;Alfred Sun&quot; - scope: path: &quot;projects&quot; type: &quot;pages&quot; # previously `page` in Jekyll 2.2. values: layout: &quot;project&quot; # overrides previous default layout Jekyll 模板、变量Jekyll 模板实际上分两部分：一部分是头部定义，另一部分是 Liquid 语法。 头部定义主要用于指定模板(layout)和定义一些变量，比如：标题(title)、描述(description)、标签(tags)、分类(category/categories)、是否发布(published)，以及其他自定义的变量。 123456789---layout: post # 指定使用的模板文件，“_layout” 目录下的模板文件名决定变量名title: title # 文章的标题date: date # 覆盖文章名中的日期category: blog # 文章的类别description: descriptionpublished: true # default true 设置 “false” 后，文章不会显示permalink: /:categories/:year/:month/:day/:title.html # 覆盖全局变量设定的文章发布格式--- 注意：如果文本文件使用的是 utf-8 编码，那么必须确保文件中不存在 BOM 头部字符，尤其是当 Jekyll 运行在 Windows 平台上。 使用变量关于 Jekyll 的变量，可以参考官方说明 上面文章页面中定义的头部变量，需要使用下面的语法获得： 1page.title 这些自定义的变量将会被传递给 Liquid 模板引擎用于转换文本文件，例如，你可以用上面定义的 “title” 变量在 layout 中设置页面的标题： 123456789&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&#123; &#123; page.title &#125; &#125; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt;&lt;/html&gt; 所有的变量都是一个树节点，比如：page 就是当前页面的根节点。 其中全局根结点有： site： _config.yml 中配置的信息 page： 页面的配置信息，包括 YAML 中定义的变量 content： 用在模板文件中，该变量包含页面的子视图，用于引入子节点的内容；不能在 post 和 page 文件中使用 paginator： 分页信息，需要事先设定 site 中的 paginate 值，参考 Pagination 注意：post 变量仅作用于 for 循环内部，如 { % for post in site.posts % } 。假如需要访问当前正在渲染的文章页面的变量，就要用 page 变量代替 post 对象。比如，post 的 title 变量，要通过 page.title 来访问。 site 下的变量 变量 描述 site.time 当前的时间(运行 Jekyll 时的时间) site.pages 所有页面列表 site.posts 按时间逆序排列的所有文章列表 site.related_posts 如果当前被处理的页面是一个 post 文件，那这个变量是一个包含了最多10篇相关的文章列表 site.static_files 所有静态文件的列表(如：没有被 Jekyll 处理的文件)，每个文件有3个属性：path、modified_time 和 extname site.html_pages 所有 HTML 页面列表 site.collections 自定义的对象集合列表，参考 Collections site.data _data 目录下 YAML 文件的数据列表 site.documents 所有 Collections 里面的文档列表 site.categories.CATEGORY 所有在 CATEGORY 类别下的 post 列表 site.tags.TAG 所有在 TAG 标签下的 post 列表 site.[CONFIGURATION_DATA] 其他自定义的变量 page 下的变量 变量 描述 page.content 页面的内容 page.title 页面的标题 page.excerpt 未渲染的摘要 page.url 不带域名的页面链接，如：/2008/12/14/my-post.html page.date 指定每一篇 post 的时间，可在 post 的 front matter 里覆盖这个值，格式是：date: YYYY-MM-DD HH:MM:SS page.id 每一篇 post 的唯一标示符(在RSS中非常有用)，如：/2008/12/14/my-post page.categories post 隶属的一个分类列表，可在 YAML 头部指定 page.tags post 隶属的一个标签列表，可在 YAML 头部指定 page.path 页面的源码地址 page.next 按时间顺序排列的下一篇文章 page.previous 按时间顺序排列的上一篇文章 paginator 下的变量分页只在 index 页面中有效，index 页面可以在子目录里，比如：主页在 /blog/index.html，那么通过配置 paginate_path: &quot;blog/page:num/&quot;，主页里面放不下的其他内容就可以设定在第 2 页 blog/page2/index.html 以及后面的页面中。 变量 描述 paginator.per_page 每一页的 post 数量 paginator.posts 当前页面上可用的 post 列表 paginator.total_posts 所有 post 的数量 paginator.total_pages 分页总数 paginator.page 当前页的页码，或者 nil paginator.previous_page 上一页的页码，或者 nil paginator.previous_page_path 上一页的路径，或者 nil paginator.next_page 下一页的页码，或者 nil paginator.next_page_path 下一页的路径，或者 nil Liquid 语法Liquid 是 Ruby 的一个模版引擎库，Jekyll中用到的Liquid标记有两种：输出和标签。 Output 标记：变成文本输出，被2层成对的花括号包住，如：{ { content } } Tag 标记：执行命令，被成对的花括号和百分号包住，如：{ % command_name % } Jekyll 输出 Output示例： 123Hello &#123; &#123; name &#125; &#125; Hello &#123; &#123; user.name &#125; &#125; Hello &#123; &#123; &apos;tobi&apos; &#125; &#125; Output 标记可以使用过滤器 Filters 对输出内容作简单处理。 多个 Filters 间用竖线隔开，从左到右依次执行，Filter 左边总是输入，返回值为下一个 Filter 的输入或最终结果。 1234Hello &#123; &#123; &apos;tobi&apos; | upcase &#125; &#125; # 转换大写输出Hello tobi has &#123; &#123; &apos;tobi&apos; | size &#125; &#125; letters! # 字符串长度Hello &#123; &#123; &apos;*tobi*&apos; | markdownify | upcase &#125; &#125; # 将Markdown字符串转成HTML大写文本输出Hello &#123; &#123; &apos;now&apos; | date: &quot;%Y %h&quot; &#125; &#125; # 按指定日期格式输出当前时间 标准过滤器 Filters下面是常用的过滤器方法，更多的API需要查阅源代码（有注释）才能看到。 源码主要看两个 Ruby Plugin 文件：filters.rb(Jekyll) 和 standardfilters.rb(Liquid)。 （这也是博主刚开始使用Jekyll的时候，比较头疼的问题。由于官方没有给出详细API的说明，只能去源代码那里看啦，好在代码的注释比较详细） date - 将时间戳转化为另一种格式 (syntax reference) capitalize - 输入字符串首字母大写 e.g. { { ‘capitalize me‘ | capitalize } } # =&gt; ‘Capitalize me‘ downcase - 输入字符串转换为小写 upcase - 输入字符串转换为大写 first - 返回数组中第一个元素 last - 返回数组数组中最后一个元素 join - 用特定的字符将数组连接成字符串输出 sort - 对数组元素排序 map - 输入数组元素的一个属性作为参数，将每个元素的属性值映射为字符串 size - 返回数组或字符串的长度 e.g. { { array | size } } escape - 将字符串转义输出 e.g. { { &quot;&lt;p&gt;test&lt;/p&gt;&quot; | escape } } # =&gt; &lt;p&gt;test&lt;/p&gt; escape_once - 返回转义后的HTML文本，不影响已经转义的HTML实体 strip_html - 删除 HTML 标签 strip_newlines - 删除字符串中的换行符(\\n) newline_to_br - 用HTML &lt;br/&gt; 替换换行符 \\n replace - 替换字符串中的指定内容 e.g. { { ‘foofoo‘ | replace:‘foo‘,‘bar‘ } } # =&gt; ‘barbar‘ replace_first - 查找并替换字符串中第一处找到的目标子串 e.g. { { ‘barbar‘ | replace_first:‘bar‘,‘foo‘ } } # =&gt; ‘foobar‘ remove - 删除字符串中的指定内容 e.g. { { ‘foobarfoobar‘ | remove:‘foo‘ } } # =&gt; ‘barbar‘ remove_first - 查找并删除字符串中第一处找到的目标子串 e.g. { { ‘barbar‘ | remove_first:‘bar‘ } } # =&gt; ‘bar‘ truncate - 截取指定长度的字符串，第2个参数追加到字符串的尾部 e.g. { { ‘foobarfoobar‘ | truncate: 5, ‘.‘ } } # =&gt; ‘foob.‘ truncatewords - 截取指定单词数量的字符串 prepend - 在字符串前面添加字符串 e.g. { { ‘bar‘ | prepend:‘foo‘ } } # =&gt; ‘foobar‘ append - 在字符串后面追加字符串 e.g. { { ‘foo‘ | append:‘bar‘ } } # =&gt; ‘foobar‘ slice - 返回字符子串指定位置开始、指定长度的子串 e.g. { { &quot;hello&quot; | slice: -4, 3 } } # =&gt; ell minus - 减法运算 e.g. { { 4 | minus:2 } } # =&gt; 2 plus - 加法运算 e.g. { { ‘1‘ | plus:‘1‘ } } #=&gt; ‘11‘, { { 1 | plus:1 } } # =&gt; 2 times - 乘法运算 e.g { { 5 | times:4 } } # =&gt; 20 divided_by - 除法运算 e.g. { { 10 | divided_by:2 } } # =&gt; 5 split - 根据匹配的表达式将字符串切成数组 e.g. { { &quot;a~b&quot; | split:&quot;~&quot; } } # =&gt; [‘a‘,‘b‘] modulo - 求模运算 e.g. { { 7 | modulo:4 } } # =&gt; 3 Jekyll 标签 Tag标签用于模板中的执行语句。目前 Jekyll/Liquid 支持的标准标签库有： Tags 说明 assign 为变量赋值 capture 用捕获到的文本为变量赋值 case 条件分支语句 case…when… comment 注释语句 cycle 通常用于在某些特定值间循环选择，如颜色、DOM类 for 循环语句 if if/else 语句 include 将另一个模板包进来，模板文件在 _includes 目录中 raw 禁用范围内的 Tag 命令，避免语法冲突 unless if 语句的否定语句 1. Comments仅起到注释 Liquid 代码的作用。 1We made 1 million dollars &#123; % comment % &#125; in losses &#123; % endcomment % &#125; this year. 2. Raw临时禁止执行 Jekyll Tag 命令，在生成的内容里存在冲突的语法片段的情况下很有用。 123&#123; % raw % &#125; In Handlebars, &#123; &#123; this &#125; &#125; will be HTML-escaped, but &#123; &#123; &#123; that &#125; &#125; &#125; will not.&#123; % endraw % &#125; 3. If / Else条件语句，可以使用关键字有：if、unless、elsif、else。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; % if user % &#125; 2 Hello &#123; &#123; user.name &#125; &#125; 3 &#123; % endif % &#125; 4 5 # Same as above 6 &#123; % if user != null % &#125; 7 Hello &#123; &#123; user.name &#125; &#125; 8 &#123; % endif % &#125; 9 10 &#123; % if user.name == &apos;tobi&apos; % &#125; 11 Hello tobi12 &#123; % elsif user.name == &apos;bob&apos; % &#125; 13 Hello bob14 &#123; % endif % &#125; 15 16 &#123; % if user.name == &apos;tobi&apos; or user.name == &apos;bob&apos; % &#125; 17 Hello tobi or bob18 &#123; % endif % &#125; 19 20 &#123; % if user.name == &apos;bob&apos; and user.age &gt; 45 % &#125; 21 Hello old bob22 &#123; % endif % &#125; 23 24 &#123; % if user.name != &apos;tobi&apos; % &#125; 25 Hello non-tobi26 &#123; % endif % &#125; 27 28 # Same as above29 &#123; % unless user.name == &apos;tobi&apos; % &#125; 30 Hello non-tobi31 &#123; % endunless % &#125; 32 33 # Check for the size of an array34 &#123; % if user.payments == empty % &#125; 35 you never paid !36 &#123; % endif % &#125; 37 38 &#123; % if user.payments.size &gt; 0 % &#125; 39 you paid !40 &#123; % endif % &#125; 41 42 &#123; % if user.age &gt; 18 % &#125; 43 Login here44 &#123; % else % &#125; 45 Sorry, you are too young46 &#123; % endif % &#125; 47 48 # array = 1,2,349 &#123; % if array contains 2 % &#125; 50 array includes 251 &#123; % endif % &#125; 52 53 # string = &apos;hello world&apos;54 &#123; % if string contains &apos;hello&apos; % &#125; 55 string includes &apos;hello&apos;56 &#123; % endif % &#125; 4. Case 语句适用于当条件实例很多的情况。 12345678 &#123; % case template % &#125; &#123; % when &apos;label&apos; % &#125; // &#123; &#123; label.title &#125; &#125; &#123; % when &apos;product&apos; % &#125; // &#123; &#123; product.vendor | link_to_vendor &#125; &#125; / &#123; &#123; product.title &#125; &#125; &#123; % else % &#125; // &#123; &#123; page_title &#125; &#125; &#123; % endcase % &#125; 5. Cycle经常需要在相似的任务间选择时，可以使用 cycle 标签。 1234567891011&#123; % cycle &apos;one&apos;, &apos;two&apos;, &apos;three&apos; % &#125; &#123; % cycle &apos;one&apos;, &apos;two&apos;, &apos;three&apos; % &#125; &#123; % cycle &apos;one&apos;, &apos;two&apos;, &apos;three&apos; % &#125; &#123; % cycle &apos;one&apos;, &apos;two&apos;, &apos;three&apos; % &#125; # =&gt;onetwothreeone 如果要对循环作分组处理，可以指定分组的名字： 12345678910&#123; % cycle &apos;group 1&apos;: &apos;one&apos;, &apos;two&apos;, &apos;three&apos; % &#125; &#123; % cycle &apos;group 1&apos;: &apos;one&apos;, &apos;two&apos;, &apos;three&apos; % &#125; &#123; % cycle &apos;group 2&apos;: &apos;one&apos;, &apos;two&apos;, &apos;three&apos; % &#125; &#123; % cycle &apos;group 2&apos;: &apos;one&apos;, &apos;two&apos;, &apos;three&apos; % &#125; # =&gt;onetwoonetwo 6. For loops循环遍历数组： 123&#123; % for item in array % &#125; &#123; &#123; item &#125; &#125; &#123; % endfor % &#125; 循环迭代 Hash散列，item[0] 是键，item[1] 是值： 123&#123; % for item in hash % &#125; &#123; &#123; item[0] &#125; &#125; : &#123; &#123; item[1] &#125; &#125; &#123; % endfor % &#125; 每个循环周期，提供下面几个可用的变量： 1234567forloop.length # =&gt; length of the entire for loopforloop.index # =&gt; index of the current iterationforloop.index0 # =&gt; index of the current iteration (zero based)forloop.rindex # =&gt; how many items are still left ?forloop.rindex0 # =&gt; how many items are still left ? (zero based)forloop.first # =&gt; is this the first iteration ?forloop.last # =&gt; is this the last iteration ? 还有几个属性用来限定循环过程： limit:int： 限制循环迭代次数 offset:int： 从第n个item开始迭代 reversed： 反转循环顺序 12345678910111213# array = [1,2,3,4,5,6]&#123; % for item in array limit:2 offset:2 % &#125; &#123; &#123; item &#125; &#125; &#123; % endfor % &#125; # results in 3,4&#123; % for item in collection reversed % &#125; &#123; &#123; item &#125; &#125; &#123; % endfor % &#125; &#123; % for post in site.posts limit:20 % &#125; &#123; &#123; post.title &#125; &#125; &#123; % endfor % &#125; 允许自定义循环迭代次数，迭代次数可以用常数或者变量说明： 12345# if item.quantity is 4...&#123; % for i in (1..item.quantity) % &#125; &#123; &#123; i &#125; &#125; &#123; % endfor % &#125; # results in 1,2,3,4 7. Variable Assignment为变量赋值，用于输出或者其他 Tag： 123456789101112131415161718&#123; % assign index = 1 % &#125; &#123; % assign name = &apos;freestyle&apos; % &#125; &#123; % for t in collections.tags % &#125; &#123; % if t == name % &#125; &lt;p&gt;Freestyle!&lt;/p&gt;&#123; % endif % &#125; &#123; % endfor % &#125; # 变量是布尔类型&#123; % assign freestyle = false % &#125; &#123; % for t in collections.tags % &#125; &#123; % if t == &apos;freestyle&apos; % &#125; &#123; % assign freestyle = true % &#125; &#123; % endif % &#125; &#123; % endfor % &#125; &#123; % if freestyle % &#125; &lt;p&gt;Freestyle!&lt;/p&gt;&#123; % endif % &#125; capture 允许将大量字符串合并为单个字符串并赋值给变量，而不会输出显示。 12345678&#123; % capture attribute_name % &#125; &#123; &#123; item.title | handleize &#125; &#125; -&#123; &#123; i &#125; &#125; -color&#123; % endcapture % &#125; &lt;label for=&quot;&#123; &#123; attribute_name &#125; &#125; &quot;&gt;Color:&lt;/label&gt;&lt;select name=&quot;attributes[&#123; &#123; attribute_name &#125; &#125; ]&quot; id=&quot;&#123; &#123; attribute_name &#125; &#125; &quot;&gt; &lt;option value=&quot;red&quot;&gt;Red&lt;/option&gt; &lt;option value=&quot;green&quot;&gt;Green&lt;/option&gt; &lt;option value=&quot;blue&quot;&gt;Blue&lt;/option&gt;&lt;/select&gt; 其他模板语句字符转义有时候想输出 { 了，怎么办？ 使用反斜线 \\ 转义即可 1\\&#123; =&gt; &#123; 格式化时间1234&#123; &#123; site.time | date_to_xmlschema &#125; &#125; # =&gt; 2008-11-07T13:07:54-08:00&#123; &#123; site.time | date_to_rfc822 &#125; &#125; # =&gt; Mon, 07 Nov 2008 13:07:54 -0800&#123; &#123; site.time | date_to_string &#125; &#125; # =&gt; 07 Nov 2008&#123; &#123; site.time | date_to_long_string &#125; &#125; # =&gt; 07 November 2008 代码语法高亮安装好 pygments.rb 的 gem 组件和 Python 2.x 后，配置文件添加：highlighter: pygments，就可以使用语法高亮命令了，支持语言多达 100 种以上。 123&#123; % highlight ruby linenos % &#125; # some ruby code&#123; % endhighlight % &#125; 上面的示例中，使用 highlight 语句来处理代码块；并设定第一个参数 ruby 来指定高亮的语言 Ruby，第二个参数 linenos 来开启显示代码行号的功能。 为了给代码着色，需要配置相应的样式文件，参考 syntax.css； 为了更好的显示行号，可以在上面的 CSS 文件添加 .lineno 样式类。 可用的语言识别符缩写，从 Pygments’ Lexers Page 查阅。 如果从 Pygments 的 Supported Languages 清單，能發現明明有列出該語言名稱，而 pygments.rb 确无法识别该语言，這時候必須到 Available Lexers 查詢；如果在程序語言的說明中有一行“ New in version 1.5. ”，那就表示只要將 Pygments 更新到 1.5 版， 即可支持该程序语言。 链接同域内的 post使用 post_url Tag 可以自动生成网站内的某个 post 超链接。 这个命令语句以相关 post 的文件名为参数，在引入同域的 post 链接时，非常有用。 12345 # 自动生成某篇文章的链接地址&#123; % post_url 2010-07-21-name-of-post % &#125; # 引入该文章的链接[Name of Link](&#123; % post_url 2010-07-21-name-of-post % &#125; ) Gist 命令嵌入 GitHub Gist，也可以指定要显示的 gist 的文件名。 12&#123; % gist parkr/931c1c8d465a04042403 % &#125; &#123; % gist parkr/931c1c8d465a04042403 jekyll-private-gist.markdown % &#125; 生成摘要配置文件中设定 excerpt_separator 取值，每篇 post 都会自动截取从开始到这个值间的内容作为这篇文章的摘要 post.excerpt 使用。 如果要禁用某篇文章的摘要，可以在该篇文章的 YAML 头部设定 excerpt_separator: &quot;&quot; 。 1234&#123; % for post in site.posts % &#125; &lt;a href=&quot;&#123; &#123; post.url &#125; &#125; &quot;&gt;&#123; &#123; post.title &#125; &#125; &lt;/a&gt; &#123; &#123; post.excerpt | remove: &apos;test&apos; &#125; &#125; &#123; % endfor % &#125; 删除 HTML 标签这个在摘要作为 head 标签里的 meta=&quot;description&quot; 内容输出时很有用 1&#123; &#123; post.excerpt | strip_html &#125; &#125; 删除指定文本过滤器 remove 可以删除变量中的指定内容 1&#123; &#123; post.url | remove: &apos;http&apos; &#125; &#125; CGI Escape通常用于将 URL 中的特殊字符转义为 %xx 形式 1&#123; &#123; &quot;foo,bar;baz?&quot; | cgi_escape &#125; &#125; # =&gt; foo%2Cbar%3Bbaz%3F 排序12345# Sort an array. Optional arguments for hashes:# 1. property name# 2. nils order (‘first‘ or ‘last‘)&#123; &#123; site.pages | sort: ‘title‘, ‘last‘ &#125; &#125; 搜索指定 Key12# Select all the objects in an array where the key has the given value.&#123; &#123; site.members | where:&quot;graduation_year&quot;,&quot;2014&quot; &#125; &#125; To JSON 格式将 Hash 散列或数组转换为 JSON 格式 1&#123; &#123; site.data.projects | jsonify &#125; &#125; 序列化把一个数组变成一个字符串 1&#123; &#123; page.tags | array_to_sentence_string &#125; &#125; # =&gt; foo, bar, and baz 单词的个数1&#123; &#123; page.content | number_of_words &#125; &#125; 内容名字规范对于博客 post，文件命名规则必须是 YEAR-MONTH-DAY-title.MARKUP 的格式。 使用 rake post 会自动将 post 文件合适命名。 比如： 123452014-11-06-memcached-code.md2014-11-06-memcached-lib.md2014-11-06-sphinx-config-and-use.md2014-11-07-memcached-hash-table.md2014-11-07-memcached-string-hash.md Assets 样式文件Jekyll 支持 Sass 和 CoffeeScript，通过新建 .sass、.scss 或 .coffee 格式的文件，并在开头添加一对 --- 来使用这个功能。 关于详细的使用，请参看官方说明，这里就不再做介绍了。","categories":[{"name":"blog","slug":"blog","permalink":"http://lmwtuedu.cn/categories/blog/"}],"tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"http://lmwtuedu.cn/tags/Jekyll/"},{"name":"Liquid","slug":"Liquid","permalink":"http://lmwtuedu.cn/tags/Liquid/"}],"author":"Alfred Sun"},{"title":"阿里Druid 配置","slug":"2018-01-19-阿里Druid","date":"2018-01-18T16:00:00.000Z","updated":"2019-09-17T08:04:02.019Z","comments":true,"path":"2018/01/19/2018-01-19-阿里Druid/","link":"","permalink":"http://lmwtuedu.cn/2018/01/19/2018-01-19-阿里Druid/","excerpt":"","text":"阿里Druid简介✈️：Druid数据连接池简介https://github.com/alibaba/druid 干货配置文件db.properties 12345678910111213141516171819202122232425262728293031323334353637383940414243url:jdbc:mysql://localhost:3306/flm?useUnicode=true&amp;characterEncoding=utf8driverClassName:com.mysql.jdbc.Driverusername:rootpassword:root#------------------------------------------------------------------------------------------#配置扩展插件 监控统计用filters:stat 日志用filters:log4j 防御sql注入用filters:wallfilters:stat#最大连接池数量 初始化建立物理连接的个数 获取连接时最长的等待时间 最小连接池数量 maxIdle已经弃用maxActive:20initialSize:1maxWait:60000minIdle:10maxIdle:15#有两个含义 1.Destroy 线程会检测连接的时间 2.testWhileIdle的判断依据timeBetweenEvictionRunsMillis:60000#Destory线程中如果检测到当前连接的最后活跃时间和当前时间的差值大于minEvictableIdleTimeMillis，则关闭当前连接minEvictableIdleTimeMillis:300000#用来检测连接是否的sql，要求是一个查询语句。在mysql中通常设置为SELECT &apos;X&apos;validationQuery:SELECT &apos;x&apos;#申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery连接是否有效testWhileIdle:true#申请连接时执行validationQuery检测连接是否有效 这个配置会降低性能testOnBorrow:false#归还连接时执行validationQuery检测连接是否有效 这个配置会降低性能testOnReturn:false#要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为truemaxOpenPreparedStatements:20#对于建立连接超过removeAbandonedTimeout的连接强制关闭removeAbandoned:true#指定连接建立多长就被强制关闭removeAbandonedTimeout:1800#指定发生removeabandoned时，是否记录当前线程的堆栈信息到日志中logAbandoned:true 在Spring配置文件application-jdbc.xml中配置阿里数据连接池Druid 123456789101112131415161718192021222324252627282930313233&lt;!-- 阿里 druid数据库连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" destroy-method=\"close\"&gt; &lt;!-- 数据库基本信息配置 --&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\" /&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driverClassName&#125;\" /&gt; &lt;property name=\"filters\" value=\"$&#123;filters&#125;\" /&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name=\"maxActive\" value=\"$&#123;maxActive&#125;\" /&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name=\"initialSize\" value=\"$&#123;initialSize&#125;\" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=\"maxWait\" value=\"$&#123;maxWait&#125;\" /&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name=\"minIdle\" value=\"$&#123;minIdle&#125;\" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"$&#123;timeBetweenEvictionRunsMillis&#125;\" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"$&#123;minEvictableIdleTimeMillis&#125;\" /&gt; &lt;property name=\"validationQuery\" value=\"$&#123;validationQuery&#125;\" /&gt; &lt;property name=\"testWhileIdle\" value=\"$&#123;testWhileIdle&#125;\" /&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;testOnBorrow&#125;\" /&gt; &lt;property name=\"testOnReturn\" value=\"$&#123;testOnReturn&#125;\" /&gt; &lt;property name=\"maxOpenPreparedStatements\" value=\"$&#123;maxOpenPreparedStatements&#125;\" /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name=\"removeAbandoned\" value=\"$&#123;removeAbandoned&#125;\" /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name=\"removeAbandonedTimeout\" value=\"$&#123;removeAbandonedTimeout&#125;\" /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name=\"logAbandoned\" value=\"$&#123;logAbandoned&#125;\" /&gt; &lt;/bean&gt; web.xml启用Web监控统计功能 12345678910111213141516171819202122&lt;!-- 连接池 启用Web监控统计功能 start--&gt; &lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;!-- 经常需要排除一些不必要的url --&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;!-- 这个StatViewServlet的用途包括：提供监控信息展示的html页面;提供监控信息的JSON API --&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 连接池 启用Web监控统计功能 end--&gt;","categories":[{"name":"code","slug":"code","permalink":"http://lmwtuedu.cn/categories/code/"}],"tags":[{"name":"Druid","slug":"Druid","permalink":"http://lmwtuedu.cn/tags/Druid/"},{"name":"DataSource","slug":"DataSource","permalink":"http://lmwtuedu.cn/tags/DataSource/"}],"author":"LJ"},{"title":"深圳-大梅沙","slug":"2018-01-13-大梅沙记录","date":"2018-01-12T16:00:00.000Z","updated":"2019-09-17T08:02:55.831Z","comments":true,"path":"2018/01/13/2018-01-13-大梅沙记录/","link":"","permalink":"http://lmwtuedu.cn/2018/01/13/2018-01-13-大梅沙记录/","excerpt":"","text":"想在你耳边物语 世界总有一些人认为： 上帝不照应，人生很无奈；时运不给力，所以很悲观；世界是客观的，它不会故意去苛待谁；地球忙着自转，世界怎么样，根本与谁无关；很多时候，压死骆驼的最后的一根稻草恰恰不是不幸本身，而是怀抱着不幸不肯撒手的心情；宁愿趴在原地等待狂风暴雨，也不想努力站起来去寻找新的栖息地。 —————活着好好的，不要急着死，因为迟早都会死。 大梅沙周末，带着相机，去了一趟大梅沙； 说来惭愧，来深圳已经两年半多了，却没去过大梅沙，也没去过小梅沙； 以前常常因为它在盐田，离我住处很远；常常以太远了作为借口，迟迟没踏出这一步； 周末下午十二点，吃完午饭，买了点水果，背着书包，踏上去看它的行程。 地铁一号线： 西乡–1号线–&gt;老街—3号线—&gt;翠竹公交： 留医部1–&gt;103 翠竹 大门 大海： 小孩 风景 结束 遇到不幸，如果真的需要别人帮助，大不了豁出去求人，但是最好只求一次——真心想帮助你的人，能帮一把就不需要你多说第二次；而不想帮你的人就算多说一百次也不过是让人家再次着一百次的借口。别像一个怨妇似的抓着一个人就大倒苦水，如果想发泄可以找最好的朋友彻底谈一回。也就一回，因为没有人喜欢复读机。————— 兵荒马乱，脆弱来袭","categories":[{"name":"life","slug":"life","permalink":"http://lmwtuedu.cn/categories/life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"http://lmwtuedu.cn/tags/Life/"},{"name":"Travel","slug":"Travel","permalink":"http://lmwtuedu.cn/tags/Travel/"}],"author":"LJ"},{"title":"MacOS 使用Ruby Gem坑","slug":"2018-01-12-MacOS使用Ruby-Gem坑","date":"2018-01-11T16:00:00.000Z","updated":"2019-09-17T08:02:40.509Z","comments":true,"path":"2018/01/12/2018-01-12-MacOS使用Ruby-Gem坑/","link":"","permalink":"http://lmwtuedu.cn/2018/01/12/2018-01-12-MacOS使用Ruby-Gem坑/","excerpt":"","text":"MacOS 使用Ruby Gem坑系统版本 系统版本 问题在OS X 下， 通过 gem安装软件遇到这种问题： You dont have write permission for the /Library/Ruby/Gems/2.3.0 directory 字面的意思即是： gem 向某个目录写文件，但是你的权限不够！ 为什么呢？ 因为你使用的是Apple自带的ruby，在尝试网Apple自家的库塞东西，默认这个位置的权限是给root的。 解决低端方案： 在前面增加： sudo gem install xxxx 另一种方法是：修改 /Library/Ruby/Gems/2.3.0 这个目录的用户 sudo chown -R your_name:your_name /Library/Ruby/Gems/2.3.0 建议方案：通过homebrew再安装一个ruby，这样 local归local， system归systembrew install ruby 安装完成之后brew安装的gem会被安装到 /usr/local/lib/ruby/gems/2.5.0 这个目录。 2.5.0 是版本位置 我们检查 gem， 发现系统里面完全用两套库了： 例如：系统目录： 系统 用户安装： 用户 从上面发现：gem install jekyll 提示不成功，因为gem运行的是系统的，需要用 /usr/local/bin/gem 安装 结束 世界就是这样，好马配好鞍， 好船配好帆， 王八对绿豆， 傻叉配脑瘫；没太大意外，万物都会自然归位。 ——–韩寒","categories":[{"name":"code","slug":"code","permalink":"http://lmwtuedu.cn/categories/code/"}],"tags":[{"name":"code","slug":"code","permalink":"http://lmwtuedu.cn/tags/code/"},{"name":"Ruby","slug":"Ruby","permalink":"http://lmwtuedu.cn/tags/Ruby/"},{"name":"Gem","slug":"Gem","permalink":"http://lmwtuedu.cn/tags/Gem/"}],"author":"LJ"},{"title":"最美的不过风景","slug":"2018-01-11-最美的不过风景","date":"2018-01-10T16:00:00.000Z","updated":"2019-09-17T08:01:37.383Z","comments":true,"path":"2018/01/11/2018-01-11-最美的不过风景/","link":"","permalink":"http://lmwtuedu.cn/2018/01/11/2018-01-11-最美的不过风景/","excerpt":"","text":"世界很大我想出去走走稻城亚丁当我想去某一个地方的时候，我会慢慢的收集关于它的一切信息； 稻城亚丁， 常常从一些旅游者提它； 我维基百科一下它具体的含义： 亚丁，藏语意为“向阳之地”； 位于中国四川省甘孜藏族自治州稻城。 主体部分是三座完全隔离，呈“品”字形排列的雪峰， 三座雪峰分号为“仙乃日”、“央迈勇”和“夏诺多吉”，其中仙乃日是一座雪峰中最高的一座，海拔6032米。 牛奶海【简介】牛奶海位于央迈神山脚下的山坳里，是一个面积不大状如水滴的古冰川湖。这里四周雪山环绕，湖水清滢碧蓝，湖畔则是一圈乳白色环绕，故称牛奶海。 牛奶海湖水深浅不一，近岸由于湖底远久植物的沉淀而略显黑色，越到深处越蓝的透亮。“滴水藏海，芥纳须弥”。 牛奶海 它就像情人的一滴蓝色眼泪，狠狠砸在了我的心上，从此以后只能相思相望不相亲 一滴蓝色眼泪 注意事项 稻城亚丁月平均气温：6月6.8℃、11月-1℃、12月-4℃. 稻城亚丁属于 高原季风气候，一年中绝大多数时间天气晴朗，阳光明媚。 高原地带，最冷月平均气温 -5℃以下，最热月平均气温10℃至12.1℃， 全年最低气温是一月份，可达-27℃； 多数夜间偶尔会有雨雪。 6～8月为雨季， 11～3月冬季。去稻城最佳季节： 4月、5月、9月、10月。 建议备上抗高原反应的药品： 肌酐、心脑舒缓、葡萄糖等药物！ 实在适应不了，切莫强行上山。 （重点区！！！） 少许补充能量的食品： 巧克力、饼干、面包等 穿运动鞋，切记！ 上山道陡峭险峻 带上一份好心情上路","categories":[{"name":"life","slug":"life","permalink":"http://lmwtuedu.cn/categories/life/"}],"tags":[{"name":"Life","slug":"Life","permalink":"http://lmwtuedu.cn/tags/Life/"},{"name":"Travel","slug":"Travel","permalink":"http://lmwtuedu.cn/tags/Travel/"}],"author":"LJ"},{"title":"MacOS命令笔记(长期更新···)","slug":"2018-01-10-mac命令笔记（长期更新...)","date":"2018-01-09T16:00:00.000Z","updated":"2019-09-17T07:59:45.727Z","comments":true,"path":"2018/01/10/2018-01-10-mac命令笔记（长期更新...)/","link":"","permalink":"http://lmwtuedu.cn/2018/01/10/2018-01-10-mac命令笔记（长期更新...)/","excerpt":"","text":"MacOS 查看端口占用情况以及杀死进程sudo lsof -i ：4000 命令 然后根据PID杀死进程：sudo kill -9 469 进程挂起/结束(1) CTRL+Z挂起进程并放入后台 (2) jobs 显示当前暂停的进程 (3) bg %N 使第N个任务在后台运行(%前有空格) (4) fg %N 使第N个任务在前台运行 默认bg,fg不带%N时表示对最后一个进程操作!","categories":[{"name":"Terminal","slug":"Terminal","permalink":"http://lmwtuedu.cn/categories/Terminal/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://lmwtuedu.cn/tags/Mac/"},{"name":"Linux","slug":"Linux","permalink":"http://lmwtuedu.cn/tags/Linux/"}],"author":"LJ"},{"title":"MacOS NTFS移动硬盘读写","slug":"2018-01-09-mac默认支持ntfs读写","date":"2018-01-08T16:00:00.000Z","updated":"2019-09-17T07:59:12.577Z","comments":true,"path":"2018/01/09/2018-01-09-mac默认支持ntfs读写/","link":"","permalink":"http://lmwtuedu.cn/2018/01/09/2018-01-09-mac默认支持ntfs读写/","excerpt":"","text":"MacOS NTFS移动硬盘读写简介mac默认支持ntfs的读写，只是普通用户默认只有读取， 没有写入（版权问题）， 可以通过以下方式打开，亲测可用。 博主系统版本： 系统版本 操作 第一步： 插入移动硬盘，列出当前移动硬盘名称 diskutil list 第二步： 编辑配置 sudo vim /etc/fstab 第三步： 设置完成之后将无法正常显示移动硬盘驱动器，所以建议一个链接或者你自己去 /Volumes 目录查看 sudo ln -s /Volumes ~/Desktop/Volumes 结束 年轻人都会迷茫，你的迷茫与社会、国家、体制没有关系，只跟你的年纪有关系，即便是六十岁的时候，你也会迷茫，这是人生每时每刻都会存在的问题，所以不要觉得迷茫时不对，特别焦虑，成为你不好好努力的借口。 —–特立独行的猫","categories":[{"name":"Terminal","slug":"Terminal","permalink":"http://lmwtuedu.cn/categories/Terminal/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://lmwtuedu.cn/tags/Mac/"},{"name":"Linux","slug":"Linux","permalink":"http://lmwtuedu.cn/tags/Linux/"}],"author":"LJ"}]}